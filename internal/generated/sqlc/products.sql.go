// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createProductParts = `-- name: CreateProductParts :one
INSERT INTO product_parts
  (id, company_id, model_id, brand_id, category_id, part_no, is_active, created_at, updated_at)
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, company_id, model_id, brand_id, category_id, part_no, oem_no, is_active, created_at, updated_at
`

type CreateProductPartsParams struct {
	ID         uuid.UUID
	CompanyID  uuid.UUID
	ModelID    uuid.UUID
	BrandID    uuid.UUID
	CategoryID uuid.UUID
	PartNo     string
	IsActive   sql.NullBool
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

// -----------------------------------------------------------------------------------------------------------------------------
// Mutation
// ------------------------------------------------------------------------------------------------------------------------
func (q *Queries) CreateProductParts(ctx context.Context, arg CreateProductPartsParams) (ProductPart, error) {
	row := q.db.QueryRowContext(ctx, createProductParts,
		arg.ID,
		arg.CompanyID,
		arg.ModelID,
		arg.BrandID,
		arg.CategoryID,
		arg.PartNo,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ProductPart
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ModelID,
		&i.BrandID,
		&i.CategoryID,
		&i.PartNo,
		&i.OemNo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProductPartByID = `-- name: DeleteProductPartByID :exec
DELETE FROM product_parts
WHERE id = $1
`

func (q *Queries) DeleteProductPartByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProductPartByID, id)
	return err
}

const deleteProductPartByPartNo = `-- name: DeleteProductPartByPartNo :exec
DELETE FROM product_parts
WHERE part_no = $1
`

func (q *Queries) DeleteProductPartByPartNo(ctx context.Context, partNo string) error {
	_, err := q.db.ExecContext(ctx, deleteProductPartByPartNo, partNo)
	return err
}

const getFilteredDetails = `-- name: GetFilteredDetails :many

SELECT
  pp.id,
  pp.part_no,
  c.name AS company_name,
  c.image_url AS company_image,
  m.name AS model_name,
  m.image_url AS model_image,
  b.name AS brand_name,
  b.image as brand_image,
  cat.name AS category_name,
  cat.image AS category_image
FROM product_parts pp
  JOIN companies c ON pp.company_id = c.id
  JOIN models m ON pp.model_id = m.id
  JOIN brands b ON pp.brand_id = b.id
  JOIN categories cat ON pp.category_id = cat.id
  JOIN model_variants mv ON pp.part_no = mv.part_no
WHERE
  -- Brand filter (only when non-empty)
  (NULLIF($1::text, '') IS NULL OR b.name = $1::text)
  AND
  -- Category filter (only when non-empty)
  (NULLIF($2::text, '') IS NULL OR cat.name = $2::text)
  AND
  (
    -- Model filter (only when non-empty)
    (
      NULLIF($3::text, '') IS NOT NULL
      AND c.name = $3::text
      AND NULLIF($4::text, '') IS NOT NULL
      AND m.name = $4::text
    )
    OR
    -- Unicode filter (only when non-empty)
    (
      NULLIF($5::text, '') IS NOT NULL
      AND EXISTS (
        SELECT 1
        FROM unnest(COALESCE(mv.unicode, '{}')) AS u
        WHERE u = $5::text
      )
    )
    OR
    -- If neither model nor unicode provided â†’ allow all
    (
      (NULLIF($3::text, '') IS NULL OR c.name = $3::text)
      AND (NULLIF($4::text, '') IS NULL)
      AND (NULLIF($5::text, '') IS NULL)
    )
  )
`

type GetFilteredDetailsParams struct {
	Brandname    string
	Categoryname string
	Companyname  string
	Modelname    string
	Unicode      string
}

type GetFilteredDetailsRow struct {
	ID            uuid.UUID
	PartNo        string
	CompanyName   string
	CompanyImage  string
	ModelName     string
	ModelImage    string
	BrandName     string
	BrandImage    string
	CategoryName  string
	CategoryImage sql.NullString
}

// @param CompanyName:sql.NullString
// @param ModelName:sql.NullString
// @param BrandName:sql.NullString
// @param CategoryName:sql.NullString
func (q *Queries) GetFilteredDetails(ctx context.Context, arg GetFilteredDetailsParams) ([]GetFilteredDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredDetails,
		arg.Brandname,
		arg.Categoryname,
		arg.Companyname,
		arg.Modelname,
		arg.Unicode,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredDetailsRow
	for rows.Next() {
		var i GetFilteredDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.PartNo,
			&i.CompanyName,
			&i.CompanyImage,
			&i.ModelName,
			&i.ModelImage,
			&i.BrandName,
			&i.BrandImage,
			&i.CategoryName,
			&i.CategoryImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredPartNo = `-- name: GetFilteredPartNo :many
SELECT id, part_no, type, gen, fuel_types, hsn_code, engine_cc, transmission_type, platform_codes, placement, image_1_link, image_2_link, image_3_link, image_4_link, make, oem_ids, vendor_id, unicode, description, additional_info, year_start, year_end
FROM model_variants mv
WHERE
  -- no search term => return everything
  NULLIF($1, '') IS NULL
  OR LOWER(mv.part_no) ILIKE '%' || LOWER($1) || '%'
  OR EXISTS (
    SELECT 1
    FROM unnest(mv.oem_ids) AS oid
    JOIN oem_listings ol
      ON ol.id::text = oid           -- oem_ids is text[], id is UUID
    WHERE LOWER(ol.oem_number) ILIKE '%' || LOWER($1) || '%'
  )
`

func (q *Queries) GetFilteredPartNo(ctx context.Context, dollar_1 interface{}) ([]ModelVariant, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredPartNo, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ModelVariant
	for rows.Next() {
		var i ModelVariant
		if err := rows.Scan(
			&i.ID,
			&i.PartNo,
			&i.Type,
			&i.Gen,
			pq.Array(&i.FuelTypes),
			&i.HsnCode,
			&i.EngineCc,
			pq.Array(&i.TransmissionType),
			pq.Array(&i.PlatformCodes),
			&i.Placement,
			&i.Image1Link,
			&i.Image2Link,
			&i.Image3Link,
			&i.Image4Link,
			&i.Make,
			pq.Array(&i.OemIds),
			pq.Array(&i.VendorID),
			pq.Array(&i.Unicode),
			&i.Description,
			&i.AdditionalInfo,
			&i.YearStart,
			&i.YearEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredProductsWithAllDetails = `-- name: GetFilteredProductsWithAllDetails :many

SELECT
  pp.part_no,

  -- Master info
  c.name AS company_name,
  m.name AS model_name,
  b.name AS brand_name,
  b.image AS brand_image,
  cat.name AS category_name,

  -- Pricing info
  pr.basic_price,
  pr.freight,
  pr.gst,
  pr.tax,

  -- Ac Workshop (formerly retail)
  pr.ac_workshop,
  pr.ac_workshop_per,
  pr.ac_workshop_amt,

  -- Multibrand Workshop (formerly wholesale)
  pr.multibrand_workshop,
  pr.multibrand_workshop_per,
  pr.multibrand_workshop_amt,

  -- Auto Trader (formerly mrp)
  pr.auto_trader,
  pr.auto_trader_per,
  pr.auto_trader_amt,

  -- AC Trader (formerly Outstation Class B)
  pr.ac_trader,
  pr.ac_trader_per,
  pr.ac_trader_amt,

  -- Outstation & notes
  pr.outstation_class_a,
  pr.outstation_note,

  -- MRPs and misc
  pr.minimum_purchase_quantity,
  pr.mrp_temp,
  pr.oem_mrp,
  pr.unit_measure,


  --Inventory Info
  inv.qty_in_stock,
  inv.minimum_order_level,
  inv.maximum_order_level,
  inv.location,
  inv.is_flash,
  inv.is_requested_for_supply,
  inv.requested_date,

  --Offer Info
  ofr.is_offer_active AS offer_status,
  ofr.start_date      AS offer_start_date,
  ofr.end_date        AS offer_end_date,

  -- pricing-oriented aliases
  ofr.ac_trader       AS ac_trader_price,
  ofr.multi_brand     AS multi_brand_price,
  ofr.autotrader      AS autotrader_price,
  ofr.ac_workshop     AS ac_workshop_price,


  -- Variants
  vnt.part_no,
  vnt.fuel_types,
  vnt.type,
  vnt.gen,
  vnt.engine_cc,
  vnt.transmission_type,
  vnt.platform_codes,
  vnt.additional_info,
  vnt.image_1_link,
  vnt.image_2_link,
  vnt.image_3_link,
  vnt.image_4_link,
  vnt.hsn_code,
  vnt.unicode,
  vnt.description,
  vnt.oem_ids,
  vnt.make,
  vnt.vendor_id,
  vnt.placement,
  vnt.year_start,
  vnt.year_end

FROM product_parts pp
  JOIN companies c ON pp.company_id = c.id
  JOIN models m ON pp.model_id = m.id
  JOIN brands b ON pp.brand_id = b.id
  JOIN categories cat ON pp.category_id = cat.id
  LEFT JOIN product_part_pricing pr ON pr.product_part_id = pp.id
  LEFT JOIN inventory inv ON inv.part_no = pp.part_no
  LEFT JOIN offer ofr ON ofr.part_no = pp.part_no
  LEFT JOIN model_variants vnt ON vnt.part_no = pp.part_no

WHERE
  (
    ($1::text IS NOT NULL AND pp.part_no = $1)
    OR
    (
      ($1::text IS NULL OR $1::text = '')
    
      AND
      (
        /* Company + Model + Category (Company only to models)*/
       (
         ($2::text IS NULL OR $2 = '' OR c.name ILIKE $2)
          AND NULLIF($3::text, '') IS NOT NULL
          AND m.name ILIKE $3::text
          AND (
            $4::text[] IS NOT NULL
            AND cat.name = ANY($4::text[])
          ) 
        )

        OR
        /* 2) EF: Unicode + UnicodeCategories (require BOTH) */
        (
            NULLIF($5::text, '') IS NOT NULL
            AND $6::text[] IS NOT NULL
            AND EXISTS (
                SELECT 1
                FROM unnest(COALESCE(vnt.unicode, '{}')) AS u
                WHERE u ILIKE $5::text
            )
            AND (
              $6::text[] IS NOT NULL
              AND cat.name = ANY($6::text[])
            )
        )
          OR
        /* 3) A B' E' F': Category-only (no model, no unicode, no unicodeCategories) */
        (
          NULLIF($3::text, '') IS NULL
          AND NULLIF($5::text, '') IS NULL
          AND $6::text[] IS NULL
          AND (
              $4::text[] IS NULL
              OR $4::text[] = '{}' 
              OR cat.name = ANY($4::text[])
          )
          AND ($2::text IS NULL OR $2 = '' OR c.name ILIKE $2)
        )
      )
      AND ($7::text[] IS NULL OR  $7::text[] = '{}'  OR b.name = ANY($7::text[]))
      AND ($8::text[] IS NULL OR  $8::text[] = '{}'  OR vnt.gen = ANY($8::text[]))
      AND ($9::text[] IS NULL OR  $9::text[] = '{}'  OR EXISTS (
        SELECT 1 
        FROM unnest(vnt.fuel_types) AS ft
        WHERE ft = ANY($9::text[])
      ))
      AND ($10::text[] IS NULL OR vnt.make = ANY($10::text[]))
    )
  )
`

type GetFilteredProductsWithAllDetailsParams struct {
	Partno              string
	Companyname         string
	Modelname           string
	Categorylist        []string
	Unicode             string
	Unicodecategorylist []string
	Brandlist           []string
	Genlist             []string
	Fuellist            []string
	Makelist            []string
}

type GetFilteredProductsWithAllDetailsRow struct {
	PartNo                  string
	CompanyName             string
	ModelName               string
	BrandName               string
	BrandImage              string
	CategoryName            string
	BasicPrice              sql.NullFloat64
	Freight                 sql.NullFloat64
	Gst                     sql.NullFloat64
	Tax                     sql.NullFloat64
	AcWorkshop              sql.NullFloat64
	AcWorkshopPer           sql.NullFloat64
	AcWorkshopAmt           sql.NullFloat64
	MultibrandWorkshop      sql.NullFloat64
	MultibrandWorkshopPer   sql.NullFloat64
	MultibrandWorkshopAmt   sql.NullFloat64
	AutoTrader              sql.NullFloat64
	AutoTraderPer           sql.NullFloat64
	AutoTraderAmt           sql.NullFloat64
	AcTrader                sql.NullFloat64
	AcTraderPer             sql.NullFloat64
	AcTraderAmt             sql.NullFloat64
	OutstationClassA        sql.NullFloat64
	OutstationNote          sql.NullString
	MinimumPurchaseQuantity sql.NullInt32
	MrpTemp                 sql.NullFloat64
	OemMrp                  sql.NullFloat64
	UnitMeasure             sql.NullString
	QtyInStock              sql.NullInt32
	MinimumOrderLevel       sql.NullInt32
	MaximumOrderLevel       sql.NullInt32
	Location                sql.NullString
	IsFlash                 sql.NullBool
	IsRequestedForSupply    sql.NullBool
	RequestedDate           sql.NullTime
	OfferStatus             sql.NullBool
	OfferStartDate          sql.NullTime
	OfferEndDate            sql.NullTime
	AcTraderPrice           []string
	MultiBrandPrice         []string
	AutotraderPrice         []string
	AcWorkshopPrice         []string
	PartNo_2                sql.NullString
	FuelTypes               []string
	Type                    sql.NullString
	Gen                     sql.NullString
	EngineCc                sql.NullFloat64
	TransmissionType        []string
	PlatformCodes           []string
	AdditionalInfo          sql.NullString
	Image1Link              sql.NullString
	Image2Link              sql.NullString
	Image3Link              sql.NullString
	Image4Link              sql.NullString
	HsnCode                 sql.NullString
	Unicode                 []string
	Description             sql.NullString
	OemIds                  []string
	Make                    sql.NullString
	VendorID                []string
	Placement               sql.NullString
	YearStart               sql.NullInt32
	YearEnd                 sql.NullInt32
}

// @param CompanyName:sql.NullString
// @param ModelName:sql.NullString
// @param PartNo:sql.NullString
// @param CategoryList:text[]
// @param BrandList:text[]
// @param GenList:text[]
// @param FuelList:text[]
// @param MakeList:text[]
// @param UnicodeCategoryList:text[]
func (q *Queries) GetFilteredProductsWithAllDetails(ctx context.Context, arg GetFilteredProductsWithAllDetailsParams) ([]GetFilteredProductsWithAllDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredProductsWithAllDetails,
		arg.Partno,
		arg.Companyname,
		arg.Modelname,
		pq.Array(arg.Categorylist),
		arg.Unicode,
		pq.Array(arg.Unicodecategorylist),
		pq.Array(arg.Brandlist),
		pq.Array(arg.Genlist),
		pq.Array(arg.Fuellist),
		pq.Array(arg.Makelist),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredProductsWithAllDetailsRow
	for rows.Next() {
		var i GetFilteredProductsWithAllDetailsRow
		if err := rows.Scan(
			&i.PartNo,
			&i.CompanyName,
			&i.ModelName,
			&i.BrandName,
			&i.BrandImage,
			&i.CategoryName,
			&i.BasicPrice,
			&i.Freight,
			&i.Gst,
			&i.Tax,
			&i.AcWorkshop,
			&i.AcWorkshopPer,
			&i.AcWorkshopAmt,
			&i.MultibrandWorkshop,
			&i.MultibrandWorkshopPer,
			&i.MultibrandWorkshopAmt,
			&i.AutoTrader,
			&i.AutoTraderPer,
			&i.AutoTraderAmt,
			&i.AcTrader,
			&i.AcTraderPer,
			&i.AcTraderAmt,
			&i.OutstationClassA,
			&i.OutstationNote,
			&i.MinimumPurchaseQuantity,
			&i.MrpTemp,
			&i.OemMrp,
			&i.UnitMeasure,
			&i.QtyInStock,
			&i.MinimumOrderLevel,
			&i.MaximumOrderLevel,
			&i.Location,
			&i.IsFlash,
			&i.IsRequestedForSupply,
			&i.RequestedDate,
			&i.OfferStatus,
			&i.OfferStartDate,
			&i.OfferEndDate,
			pq.Array(&i.AcTraderPrice),
			pq.Array(&i.MultiBrandPrice),
			pq.Array(&i.AutotraderPrice),
			pq.Array(&i.AcWorkshopPrice),
			&i.PartNo_2,
			pq.Array(&i.FuelTypes),
			&i.Type,
			&i.Gen,
			&i.EngineCc,
			pq.Array(&i.TransmissionType),
			pq.Array(&i.PlatformCodes),
			&i.AdditionalInfo,
			&i.Image1Link,
			&i.Image2Link,
			&i.Image3Link,
			&i.Image4Link,
			&i.HsnCode,
			pq.Array(&i.Unicode),
			&i.Description,
			pq.Array(&i.OemIds),
			&i.Make,
			pq.Array(&i.VendorID),
			&i.Placement,
			&i.YearStart,
			&i.YearEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductPartInfoByPartNo = `-- name: GetProductPartInfoByPartNo :one
SELECT 
  cnpy.name AS company_name,
  mdl.name AS model_name,
  ctgr.name AS category_name,
  brnd.name AS brand_name
FROM product_parts p
LEFT JOIN companies cnpy ON cnpy.id = p.company_id
LEFT JOIN models mdl ON mdl.id = p.model_id
LEFT JOIN categories ctgr ON ctgr.id = p.category_id
LEFT JOIN brands brnd ON brnd.id = p.brand_id
WHERE p.part_no = $1
`

type GetProductPartInfoByPartNoRow struct {
	CompanyName  sql.NullString
	ModelName    sql.NullString
	CategoryName sql.NullString
	BrandName    sql.NullString
}

func (q *Queries) GetProductPartInfoByPartNo(ctx context.Context, partNo string) (GetProductPartInfoByPartNoRow, error) {
	row := q.db.QueryRowContext(ctx, getProductPartInfoByPartNo, partNo)
	var i GetProductPartInfoByPartNoRow
	err := row.Scan(
		&i.CompanyName,
		&i.ModelName,
		&i.CategoryName,
		&i.BrandName,
	)
	return i, err
}

const getProductPartNo = `-- name: GetProductPartNo :many
SELECT part_no from product_parts WHERE part_no=$1
`

func (q *Queries) GetProductPartNo(ctx context.Context, partNo string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getProductPartNo, partNo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var part_no string
		if err := rows.Scan(&part_no); err != nil {
			return nil, err
		}
		items = append(items, part_no)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductPartNos = `-- name: GetProductPartNos :many
SELECT part_no
FROM product_parts
WHERE part_no ILIKE '%' || $1 || '%'
ORDER BY part_no
LIMIT 10
`

func (q *Queries) GetProductPartNos(ctx context.Context, dollar_1 sql.NullString) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getProductPartNos, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var part_no string
		if err := rows.Scan(&part_no); err != nil {
			return nil, err
		}
		items = append(items, part_no)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductPartsByPartNo = `-- name: GetProductPartsByPartNo :one

SELECT id, company_id, model_id, brand_id, category_id, part_no, oem_no, is_active, created_at, updated_at FROM product_parts WHERE part_no=$1
`

// ---------------------------------------------------------------------------------------------------------------------------
// Query
// --------------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetProductPartsByPartNo(ctx context.Context, partNo string) (ProductPart, error) {
	row := q.db.QueryRowContext(ctx, getProductPartsByPartNo, partNo)
	var i ProductPart
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ModelID,
		&i.BrandID,
		&i.CategoryID,
		&i.PartNo,
		&i.OemNo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductPartByID = `-- name: UpdateProductPartByID :one
UPDATE product_parts AS pp
SET
  company_id    = COALESCE($2, pp.company_id),
  model_id      = COALESCE($3, pp.model_id),
  brand_id      = COALESCE($4, pp.brand_id),
  category_id   = COALESCE($5, pp.category_id),
  part_no       = COALESCE($6, pp.part_no),
  is_active     = COALESCE($7, pp.is_active),
  updated_at    = NOW()
WHERE pp.id = $1
RETURNING id, company_id, model_id, brand_id, category_id, part_no, oem_no, is_active, created_at, updated_at
`

type UpdateProductPartByIDParams struct {
	ID            uuid.UUID
	NewCompanyID  uuid.NullUUID
	NewModelID    uuid.NullUUID
	NewBrandID    uuid.NullUUID
	NewCategoryID uuid.NullUUID
	NewPartNo     sql.NullString
	NewIsActive   sql.NullBool
}

func (q *Queries) UpdateProductPartByID(ctx context.Context, arg UpdateProductPartByIDParams) (ProductPart, error) {
	row := q.db.QueryRowContext(ctx, updateProductPartByID,
		arg.ID,
		arg.NewCompanyID,
		arg.NewModelID,
		arg.NewBrandID,
		arg.NewCategoryID,
		arg.NewPartNo,
		arg.NewIsActive,
	)
	var i ProductPart
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ModelID,
		&i.BrandID,
		&i.CategoryID,
		&i.PartNo,
		&i.OemNo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
