// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: type.sql

package sqlc

import (
	"context"
)

const filterVariantTypes = `-- name: FilterVariantTypes :many
SELECT DISTINCT
  m2."type"
FROM product_parts p
JOIN model_variants m2 ON m2.part_no = p.part_no
JOIN companies c       ON c.id = p.company_id
JOIN models m          ON m.id = p.model_id
JOIN categories cat    ON cat.id = p.category_id
WHERE (NULLIF($1::text, '') IS NULL OR UPPER(c.name) = UPPER($1))
  AND (NULLIF($2::text, '') IS NULL OR UPPER(m.name) = UPPER($2))
  AND (NULLIF($3::text, '') IS NULL OR UPPER(cat.name) = UPPER($3))
  AND (NULLIF($4::text, '') IS NULL OR UPPER(m2."type") LIKE '%' || UPPER($4) || '%')
ORDER BY m2."type"
`

type FilterVariantTypesParams struct {
	Column1 string
	Column2 string
	Column3 string
	Column4 string
}

func (q *Queries) FilterVariantTypes(ctx context.Context, arg FilterVariantTypesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, filterVariantTypes,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var type_ string
		if err := rows.Scan(&type_); err != nil {
			return nil, err
		}
		items = append(items, type_)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
