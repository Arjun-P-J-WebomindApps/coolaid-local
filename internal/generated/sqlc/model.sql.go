// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: model.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createModel = `-- name: CreateModel :one

INSERT INTO models
    (id, company_id, name, image_url)
VALUES
    ($1, $2, $3, $4)
RETURNING id, company_id, name, image_url
`

type CreateModelParams struct {
	ID        uuid.UUID
	CompanyID uuid.UUID
	Name      string
	ImageUrl  string
}

// ----------------------------------------------------------------------------------------------------------------------------
// Mutation
// ----------------------------------------------------------------------------------------------------------------------------
func (q *Queries) CreateModel(ctx context.Context, arg CreateModelParams) (Model, error) {
	row := q.db.QueryRowContext(ctx, createModel,
		arg.ID,
		arg.CompanyID,
		arg.Name,
		arg.ImageUrl,
	)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.ImageUrl,
	)
	return i, err
}

const deleteModelByID = `-- name: DeleteModelByID :exec
DELETE FROM models
WHERE id = $1
`

func (q *Queries) DeleteModelByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteModelByID, id)
	return err
}

const getModelById = `-- name: GetModelById :one


SELECT id, company_id, name, image_url
FROM models
WHERE id=$1
`

// ---------------------------------------------------------------------------------------------------------------------------
// Queries
// --------------------------------------------------------------------------------------------------------------------------
// -----------used to identify if the input model exists in database or not--#
func (q *Queries) GetModelById(ctx context.Context, id uuid.UUID) (Model, error) {
	row := q.db.QueryRowContext(ctx, getModelById, id)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.ImageUrl,
	)
	return i, err
}

const getModelByName = `-- name: GetModelByName :one
SELECT id, company_id, name, image_url
FROM models
WHERE name=$1
`

func (q *Queries) GetModelByName(ctx context.Context, name string) (Model, error) {
	row := q.db.QueryRowContext(ctx, getModelByName, name)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.ImageUrl,
	)
	return i, err
}

const getModelByNameAndCompany = `-- name: GetModelByNameAndCompany :one
SELECT m.id,
m.name as model_name,
c.name as company_name
FROM models m
JOIN companies c ON c.id = m.company_id
WHERE c.name = $1::text
  AND m.name = $2::text
`

type GetModelByNameAndCompanyParams struct {
	Companyname string
	Modelname   string
}

type GetModelByNameAndCompanyRow struct {
	ID          uuid.UUID
	ModelName   string
	CompanyName string
}

// params
func (q *Queries) GetModelByNameAndCompany(ctx context.Context, arg GetModelByNameAndCompanyParams) (GetModelByNameAndCompanyRow, error) {
	row := q.db.QueryRowContext(ctx, getModelByNameAndCompany, arg.Companyname, arg.Modelname)
	var i GetModelByNameAndCompanyRow
	err := row.Scan(&i.ID, &i.ModelName, &i.CompanyName)
	return i, err
}

const getModelSimilar = `-- name: GetModelSimilar :many

SELECT id, company_id, name, image_url
FROM models
WHERE LOWER(name) ILIKE LOWER($1)
`

// ------------used in search engine to identify models like 800,i20 etc-----#
func (q *Queries) GetModelSimilar(ctx context.Context, lower string) ([]Model, error) {
	rows, err := q.db.QueryContext(ctx, getModelSimilar, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelsByCompanyAndModel = `-- name: GetModelsByCompanyAndModel :many

SELECT m.name as model_name, c.name as company_name, m.id,m.image_url
FROM models m
JOIN companies c ON c.id = m.company_id
WHERE
  ($1 = '' OR c.name ILIKE '%' || $1 || '%')
  AND
  ($2 = '' OR m.name ILIKE '%' || $2 || '%') ORDER BY m.name ASC
`

type GetModelsByCompanyAndModelParams struct {
	Column1 interface{}
	Column2 interface{}
}

type GetModelsByCompanyAndModelRow struct {
	ModelName   string
	CompanyName string
	ID          uuid.UUID
	ImageUrl    string
}

// -------------- used by forms to get suggestions --------------------------#
func (q *Queries) GetModelsByCompanyAndModel(ctx context.Context, arg GetModelsByCompanyAndModelParams) ([]GetModelsByCompanyAndModelRow, error) {
	rows, err := q.db.QueryContext(ctx, getModelsByCompanyAndModel, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModelsByCompanyAndModelRow
	for rows.Next() {
		var i GetModelsByCompanyAndModelRow
		if err := rows.Scan(
			&i.ModelName,
			&i.CompanyName,
			&i.ID,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateModelByID = `-- name: UpdateModelByID :one
UPDATE models AS m SET
  company_id = COALESCE($2, m.company_id),
  name       = COALESCE($3, m.name),
  image_url  = COALESCE($4, m.image_url)
WHERE m.id = $1
RETURNING id, company_id, name, image_url
`

type UpdateModelByIDParams struct {
	ID        uuid.UUID
	CompanyID uuid.NullUUID
	ModelName sql.NullString
	ImageUrl  sql.NullString
}

func (q *Queries) UpdateModelByID(ctx context.Context, arg UpdateModelByIDParams) (Model, error) {
	row := q.db.QueryRowContext(ctx, updateModelByID,
		arg.ID,
		arg.CompanyID,
		arg.ModelName,
		arg.ImageUrl,
	)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.ImageUrl,
	)
	return i, err
}
