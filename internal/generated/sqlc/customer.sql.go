// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customer.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one


INSERT INTO customers
    (id,customer_company_name,contact_person,mobile,type,customer_designation,address,flat,street,city,state,pincode,payment_mode,created_at,updated_at,deleted_at)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
`

type CreateCustomerParams struct {
	ID                  uuid.UUID
	CustomerCompanyName string
	ContactPerson       string
	Mobile              string
	Type                string
	CustomerDesignation sql.NullString
	Address             sql.NullString
	Flat                sql.NullString
	Street              sql.NullString
	City                sql.NullString
	State               sql.NullString
	Pincode             sql.NullString
	PaymentMode         sql.NullString
	CreatedAt           time.Time
	UpdatedAt           time.Time
	DeletedAt           sql.NullTime
}

// ---------------------------------------------------------------------------------------------------------------------------
// MUTATION
// ---------------------------------------------------------------------------------------------------------------------------
func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.ID,
		arg.CustomerCompanyName,
		arg.ContactPerson,
		arg.Mobile,
		arg.Type,
		arg.CustomerDesignation,
		arg.Address,
		arg.Flat,
		arg.Street,
		arg.City,
		arg.State,
		arg.Pincode,
		arg.PaymentMode,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerCompanyName,
		&i.ContactPerson,
		&i.Mobile,
		&i.Type,
		&i.CustomerDesignation,
		&i.Address,
		&i.Flat,
		&i.Street,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.PaymentMode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCustomerByID = `-- name: DeleteCustomerByID :one
DELETE FROM customers
WHERE id = $1
RETURNING id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
`

func (q *Queries) DeleteCustomerByID(ctx context.Context, id uuid.UUID) (Customer, error) {
	row := q.db.QueryRowContext(ctx, deleteCustomerByID, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerCompanyName,
		&i.ContactPerson,
		&i.Mobile,
		&i.Type,
		&i.CustomerDesignation,
		&i.Address,
		&i.Flat,
		&i.Street,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.PaymentMode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllCustomers = `-- name: GetAllCustomers :many

SELECT id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
FROM customers
`

// -----------------------------------------------------------------------------------------------------------------------------
// Query
// -----------------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetAllCustomers(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, getAllCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.CustomerCompanyName,
			&i.ContactPerson,
			&i.Mobile,
			&i.Type,
			&i.CustomerDesignation,
			&i.Address,
			&i.Flat,
			&i.Street,
			&i.City,
			&i.State,
			&i.Pincode,
			&i.PaymentMode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByMobileCompanyContactPersonAndCustomerType = `-- name: GetCustomerByMobileCompanyContactPersonAndCustomerType :one
SELECT id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
FROM customers
WHERE mobile = $1::text
  AND customer_company_name = $2::text
  AND contact_person = $3::text
  AND type = $4::text
`

type GetCustomerByMobileCompanyContactPersonAndCustomerTypeParams struct {
	Mobile              string
	Customercompanyname string
	Contactperson       string
	Customertype        string
}

func (q *Queries) GetCustomerByMobileCompanyContactPersonAndCustomerType(ctx context.Context, arg GetCustomerByMobileCompanyContactPersonAndCustomerTypeParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByMobileCompanyContactPersonAndCustomerType,
		arg.Mobile,
		arg.Customercompanyname,
		arg.Contactperson,
		arg.Customertype,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerCompanyName,
		&i.ContactPerson,
		&i.Mobile,
		&i.Type,
		&i.CustomerDesignation,
		&i.Address,
		&i.Flat,
		&i.Street,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.PaymentMode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCustomerByMobileNumber = `-- name: GetCustomerByMobileNumber :one
SELECT id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
FROM customers
WHERE mobile=$1
`

func (q *Queries) GetCustomerByMobileNumber(ctx context.Context, mobile string) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByMobileNumber, mobile)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerCompanyName,
		&i.ContactPerson,
		&i.Mobile,
		&i.Type,
		&i.CustomerDesignation,
		&i.Address,
		&i.Flat,
		&i.Street,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.PaymentMode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCustomerFromID = `-- name: GetCustomerFromID :one
SELECT id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
FROM customers
WHERE id=$1
`

func (q *Queries) GetCustomerFromID(ctx context.Context, id uuid.UUID) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerFromID, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerCompanyName,
		&i.ContactPerson,
		&i.Mobile,
		&i.Type,
		&i.CustomerDesignation,
		&i.Address,
		&i.Flat,
		&i.Street,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.PaymentMode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCustomersFromName = `-- name: GetCustomersFromName :many
SELECT id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
FROM customers
WHERE customer_company_name=$1
`

func (q *Queries) GetCustomersFromName(ctx context.Context, customerCompanyName string) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, getCustomersFromName, customerCompanyName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.CustomerCompanyName,
			&i.ContactPerson,
			&i.Mobile,
			&i.Type,
			&i.CustomerDesignation,
			&i.Address,
			&i.Flat,
			&i.Street,
			&i.City,
			&i.State,
			&i.Pincode,
			&i.PaymentMode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomersByAttributes = `-- name: SearchCustomersByAttributes :many
SELECT id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
FROM customers
WHERE 
    (
        NULLIF($1::text,'') IS NULL OR 
        LOWER(customer_company_name) ILIKE '%' || LOWER($1::text) || '%'
    )
  OR
    (   
        NULLIF($2::text,'') IS NULL OR 
        LOWER(contact_person) ILIKE '%' || LOWER($2::text) || '%'
    )
  OR
    (
        NULLIF($3::text ,'')IS NULL OR
        mobile ILIKE '%' || $3::text || '%'
    )
  ORDER BY customer_company_name ASC
`

type SearchCustomersByAttributesParams struct {
	CustomerCompanyName string
	ContactPerson       string
	Mobile              string
}

func (q *Queries) SearchCustomersByAttributes(ctx context.Context, arg SearchCustomersByAttributesParams) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, searchCustomersByAttributes, arg.CustomerCompanyName, arg.ContactPerson, arg.Mobile)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.CustomerCompanyName,
			&i.ContactPerson,
			&i.Mobile,
			&i.Type,
			&i.CustomerDesignation,
			&i.Address,
			&i.Flat,
			&i.Street,
			&i.City,
			&i.State,
			&i.Pincode,
			&i.PaymentMode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomerByID = `-- name: UpdateCustomerByID :one
UPDATE customers AS c SET
  customer_company_name = COALESCE($2, c.customer_company_name),
  contact_person        = COALESCE($3, c.contact_person),
  mobile                = COALESCE($4, c.mobile),
  type                  = COALESCE($5, c.type),
  customer_designation  = COALESCE($6, c.customer_designation),
  address               = COALESCE($7, c.address),
  flat                  = COALESCE($8, c.flat),
  street                = COALESCE($9, c.street),
  city                  = COALESCE($10, c.city),
  state                 = COALESCE($11, c.state),
  pincode               = COALESCE($12, c.pincode),
  payment_mode          = COALESCE($13, c.payment_mode),
  updated_at            = NOW()
WHERE c.id = $1
RETURNING id, customer_company_name, contact_person, mobile, type, customer_designation, address, flat, street, city, state, pincode, payment_mode, created_at, updated_at, deleted_at
`

type UpdateCustomerByIDParams struct {
	ID                  uuid.UUID
	CustomerCompanyName sql.NullString
	ContactPerson       sql.NullString
	Mobile              sql.NullString
	Type                sql.NullString
	CustomerDesignation sql.NullString
	Address             sql.NullString
	Flat                sql.NullString
	Street              sql.NullString
	City                sql.NullString
	State               sql.NullString
	Pincode             sql.NullString
	PaymentMode         sql.NullString
}

func (q *Queries) UpdateCustomerByID(ctx context.Context, arg UpdateCustomerByIDParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, updateCustomerByID,
		arg.ID,
		arg.CustomerCompanyName,
		arg.ContactPerson,
		arg.Mobile,
		arg.Type,
		arg.CustomerDesignation,
		arg.Address,
		arg.Flat,
		arg.Street,
		arg.City,
		arg.State,
		arg.Pincode,
		arg.PaymentMode,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.CustomerCompanyName,
		&i.ContactPerson,
		&i.Mobile,
		&i.Type,
		&i.CustomerDesignation,
		&i.Address,
		&i.Flat,
		&i.Street,
		&i.City,
		&i.State,
		&i.Pincode,
		&i.PaymentMode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
