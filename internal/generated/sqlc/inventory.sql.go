// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const bulkUpdateInventorySelective = `-- name: BulkUpdateInventorySelective :exec

WITH data AS (
  SELECT
    UNNEST($1::text[])  AS part_no,
    UNNEST($2::int4[])      AS qty_in_stock_raw,
    UNNEST($3::int4[])  AS maximum_order_level_raw,
    UNNEST($4::int4[])  AS minimum_order_level_raw,
    UNNEST($5::text[]) AS location_raw,
    UNNEST($6::bool[]) AS is_flash
)
UPDATE inventory inv
SET
  qty_in_stock        = COALESCE(NULLIF(d.qty_in_stock_raw,        -1), inv.qty_in_stock),
  maximum_order_level = COALESCE(NULLIF(d.maximum_order_level_raw, -1), inv.maximum_order_level),
  minimum_order_level = COALESCE(NULLIF(d.minimum_order_level_raw, -1), inv.minimum_order_level),
  location            = COALESCE(NULLIF(d.location_raw, ''),           inv.location),
  is_flash            = d.is_flash
FROM data d
WHERE inv.part_no = d.part_no
`

type BulkUpdateInventorySelectiveParams struct {
	PartNos   []string
	Qtys      []int32
	MaxLvls   []int32
	MinLvls   []int32
	Locations []string
	IsFlashes []bool
}

// -------------------------------------------------------------------
// üöÄ BULK UPDATE (by part_no)
// Updates many inventory rows in ONE statement using array UNNEST.
// Keep arrays the same length and aligned by index.
// -------------------------------------------------------------------
func (q *Queries) BulkUpdateInventorySelective(ctx context.Context, arg BulkUpdateInventorySelectiveParams) error {
	_, err := q.db.ExecContext(ctx, bulkUpdateInventorySelective,
		pq.Array(arg.PartNos),
		pq.Array(arg.Qtys),
		pq.Array(arg.MaxLvls),
		pq.Array(arg.MinLvls),
		pq.Array(arg.Locations),
		pq.Array(arg.IsFlashes),
	)
	return err
}

const createInventoryProduct = `-- name: CreateInventoryProduct :one

INSERT INTO inventory
  (
  id,
  part_no,
  minimum_order_level,
  maximum_order_level,
  qty_in_stock,
  location,
  is_flash,
  is_requested_for_supply,
  vendor_id
  )
VALUES
  (
    $1, -- id
    $2, -- part_no
    $3, -- minimum_order_level
    $4, -- maximum_order_level
    $5, -- qty_in_stock
    $6, -- location
    $7, -- is_flash
    $8, -- is_requested_for_supply
    $9   -- vendor_id
)
RETURNING id, part_no, minimum_order_level, maximum_order_level, qty_in_stock, location, is_flash, is_requested_for_supply, requested_date, vendor_id
`

type CreateInventoryProductParams struct {
	ID                   uuid.UUID
	PartNo               string
	MinimumOrderLevel    int32
	MaximumOrderLevel    int32
	QtyInStock           int32
	Location             string
	IsFlash              sql.NullBool
	IsRequestedForSupply sql.NullBool
	VendorID             uuid.NullUUID
}

// -------------------------------------------------------------------
// ‚öôÔ∏è MUTATIONS (Write Operations)
// These statements CREATE, UPDATE, or DELETE data in the database.
// They modify the state of the system.
// -------------------------------------------------------------------
func (q *Queries) CreateInventoryProduct(ctx context.Context, arg CreateInventoryProductParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, createInventoryProduct,
		arg.ID,
		arg.PartNo,
		arg.MinimumOrderLevel,
		arg.MaximumOrderLevel,
		arg.QtyInStock,
		arg.Location,
		arg.IsFlash,
		arg.IsRequestedForSupply,
		arg.VendorID,
	)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.PartNo,
		&i.MinimumOrderLevel,
		&i.MaximumOrderLevel,
		&i.QtyInStock,
		&i.Location,
		&i.IsFlash,
		&i.IsRequestedForSupply,
		&i.RequestedDate,
		&i.VendorID,
	)
	return i, err
}

const deleteInventoryProductByPartNo = `-- name: DeleteInventoryProductByPartNo :exec
DELETE FROM inventory
WHERE part_no = $1
`

func (q *Queries) DeleteInventoryProductByPartNo(ctx context.Context, partNo string) error {
	_, err := q.db.ExecContext(ctx, deleteInventoryProductByPartNo, partNo)
	return err
}

const getInventoryDetailsForBulkDownload = `-- name: GetInventoryDetailsForBulkDownload :many
SELECT
  pp.part_no AS "Part No",
  c.name AS "Company",
  m.name AS "Model",
  b.name AS "Brand",
  cat.name AS "Category",
  inv.id, inv.part_no, inv.minimum_order_level, inv.maximum_order_level, inv.qty_in_stock, inv.location, inv.is_flash, inv.is_requested_for_supply, inv.requested_date, inv.vendor_id
FROM inventory inv
  join product_parts pp on pp.part_no=inv.part_no
  JOIN companies c ON c.id = pp.company_id
  JOIN models m ON m.id = pp.model_id
  JOIN brands b ON b.id = pp.brand_id
  JOIN categories cat ON cat.id = pp.category_id
  JOIN model_variants vnt ON vnt.part_no=pp.part_no
`

type GetInventoryDetailsForBulkDownloadRow struct {
	PartNo               string
	Company              string
	Model                string
	Brand                string
	Category             string
	ID                   uuid.UUID
	PartNo_2             string
	MinimumOrderLevel    int32
	MaximumOrderLevel    int32
	QtyInStock           int32
	Location             string
	IsFlash              sql.NullBool
	IsRequestedForSupply sql.NullBool
	RequestedDate        sql.NullTime
	VendorID             uuid.NullUUID
}

func (q *Queries) GetInventoryDetailsForBulkDownload(ctx context.Context) ([]GetInventoryDetailsForBulkDownloadRow, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryDetailsForBulkDownload)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInventoryDetailsForBulkDownloadRow
	for rows.Next() {
		var i GetInventoryDetailsForBulkDownloadRow
		if err := rows.Scan(
			&i.PartNo,
			&i.Company,
			&i.Model,
			&i.Brand,
			&i.Category,
			&i.ID,
			&i.PartNo_2,
			&i.MinimumOrderLevel,
			&i.MaximumOrderLevel,
			&i.QtyInStock,
			&i.Location,
			&i.IsFlash,
			&i.IsRequestedForSupply,
			&i.RequestedDate,
			&i.VendorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryProductByPartNo = `-- name: GetInventoryProductByPartNo :one

SELECT id, part_no, minimum_order_level, maximum_order_level, qty_in_stock, location, is_flash, is_requested_for_supply, requested_date, vendor_id
FROM inventory
WHERE part_no = $1
`

// -------------------------------------------------------------------
// üìò QUERIES (Read Operations)
// These statements only READ data from the database.
// They do not modify any existing data.
// -------------------------------------------------------------------
func (q *Queries) GetInventoryProductByPartNo(ctx context.Context, partNo string) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getInventoryProductByPartNo, partNo)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.PartNo,
		&i.MinimumOrderLevel,
		&i.MaximumOrderLevel,
		&i.QtyInStock,
		&i.Location,
		&i.IsFlash,
		&i.IsRequestedForSupply,
		&i.RequestedDate,
		&i.VendorID,
	)
	return i, err
}

const outOfStockCommodities = `-- name: OutOfStockCommodities :many
SELECT inv.id, inv.part_no, inv.minimum_order_level, inv.maximum_order_level, inv.qty_in_stock, inv.location, inv.is_flash, inv.is_requested_for_supply, inv.requested_date, inv.vendor_id, vndr.company_name as vendor,mdl.name as model,c.name as category,vndr_list.vendor_part_no as vendor_part_no
FROM inventory inv
  join vendors vndr on inv.vendor_id=vndr.id
  join product_parts pp  on pp.part_no=inv.part_no
  join models mdl on mdl.id=pp.model_id
  join categories c on c.id=pp.category_id
  LEFT JOIN vendor_listing vndr_list ON vndr_list.product_part_no = pp.part_no 
WHERE inv.is_requested_for_supply = FALSE
  AND inv.qty_in_stock < inv.minimum_order_level
`

type OutOfStockCommoditiesRow struct {
	ID                   uuid.UUID
	PartNo               string
	MinimumOrderLevel    int32
	MaximumOrderLevel    int32
	QtyInStock           int32
	Location             string
	IsFlash              sql.NullBool
	IsRequestedForSupply sql.NullBool
	RequestedDate        sql.NullTime
	VendorID             uuid.NullUUID
	Vendor               string
	Model                string
	Category             string
	VendorPartNo         sql.NullString
}

func (q *Queries) OutOfStockCommodities(ctx context.Context) ([]OutOfStockCommoditiesRow, error) {
	rows, err := q.db.QueryContext(ctx, outOfStockCommodities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OutOfStockCommoditiesRow
	for rows.Next() {
		var i OutOfStockCommoditiesRow
		if err := rows.Scan(
			&i.ID,
			&i.PartNo,
			&i.MinimumOrderLevel,
			&i.MaximumOrderLevel,
			&i.QtyInStock,
			&i.Location,
			&i.IsFlash,
			&i.IsRequestedForSupply,
			&i.RequestedDate,
			&i.VendorID,
			&i.Vendor,
			&i.Model,
			&i.Category,
			&i.VendorPartNo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryProductByPartNo = `-- name: UpdateInventoryProductByPartNo :one
UPDATE inventory AS inv
SET
  minimum_order_level
= COALESCE
($2, inv.minimum_order_level),
  maximum_order_level       = COALESCE
($3, inv.maximum_order_level),
  qty_in_stock              = COALESCE
($4, inv.qty_in_stock),
  location                  = COALESCE
($5, inv.location),
  is_flash                  = COALESCE
($6, inv.is_flash),
  is_requested_for_supply   = COALESCE
($7, inv.is_requested_for_supply),
  vendor_id                 = COALESCE
($8, inv.vendor_id)
WHERE part_no = $1
RETURNING id, part_no, minimum_order_level, maximum_order_level, qty_in_stock, location, is_flash, is_requested_for_supply, requested_date, vendor_id
`

type UpdateInventoryProductByPartNoParams struct {
	PartNo               string
	MinimumOrderLevel    int32
	MaximumOrderLevel    int32
	QtyInStock           int32
	Location             string
	IsFlash              sql.NullBool
	IsRequestedForSupply sql.NullBool
	VendorID             uuid.NullUUID
}

func (q *Queries) UpdateInventoryProductByPartNo(ctx context.Context, arg UpdateInventoryProductByPartNoParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryProductByPartNo,
		arg.PartNo,
		arg.MinimumOrderLevel,
		arg.MaximumOrderLevel,
		arg.QtyInStock,
		arg.Location,
		arg.IsFlash,
		arg.IsRequestedForSupply,
		arg.VendorID,
	)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.PartNo,
		&i.MinimumOrderLevel,
		&i.MaximumOrderLevel,
		&i.QtyInStock,
		&i.Location,
		&i.IsFlash,
		&i.IsRequestedForSupply,
		&i.RequestedDate,
		&i.VendorID,
	)
	return i, err
}
