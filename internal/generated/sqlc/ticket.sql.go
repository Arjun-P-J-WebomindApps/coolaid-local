// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ticket.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createTicket = `-- name: CreateTicket :one

INSERT INTO tickets (
  id,
  ticket_date,
  customer_id,
  daily_number,
  status,
  images_included,
  transport_mode,
  inspection_images,
  check_for_damage,
  remove_all_labels,
  exclude_documents,
  urgent_requirement,
  paf,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  COALESCE($6, false),
  COALESCE($7, 'porter'),
  COALESCE($8::TEXT[], ARRAY[]::TEXT[]),
  COALESCE($9, false),
  COALESCE($10, false),
  COALESCE($11, false),
  COALESCE($12, false),
  COALESCE($13, 0),
  COALESCE($14, now())
)
RETURNING id, ticket_date, customer_id, daily_number, paf, images_included, status, transport_mode, inspection_images, confirm_order_date, check_for_damage, remove_all_labels, exclude_documents, urgent_requirement, created_at
`

type CreateTicketParams struct {
	ID                uuid.UUID
	TicketDate        time.Time
	CustomerID        uuid.UUID
	DailyNumber       string
	Status            string
	ImagesIncluded    interface{}
	TransportMode     interface{}
	InspectionImages  []string
	CheckForDamage    interface{}
	RemoveAllLabels   interface{}
	ExcludeDocuments  interface{}
	UrgentRequirement interface{}
	Paf               interface{}
	CreatedAt         interface{}
}

// -----------------------------------------------------------------------------------------------------------------------------
// Mutation (Tickets)
// ----------------------------------------------------------------------------------------------------------------------------------
func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.ID,
		arg.TicketDate,
		arg.CustomerID,
		arg.DailyNumber,
		arg.Status,
		arg.ImagesIncluded,
		arg.TransportMode,
		pq.Array(arg.InspectionImages),
		arg.CheckForDamage,
		arg.RemoveAllLabels,
		arg.ExcludeDocuments,
		arg.UrgentRequirement,
		arg.Paf,
		arg.CreatedAt,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.TicketDate,
		&i.CustomerID,
		&i.DailyNumber,
		&i.Paf,
		&i.ImagesIncluded,
		&i.Status,
		&i.TransportMode,
		pq.Array(&i.InspectionImages),
		&i.ConfirmOrderDate,
		&i.CheckForDamage,
		&i.RemoveAllLabels,
		&i.ExcludeDocuments,
		&i.UrgentRequirement,
		&i.CreatedAt,
	)
	return i, err
}

const createTicketItem = `-- name: CreateTicketItem :one

INSERT INTO ticket_items (id,ticket_id,part_no,model,quantity,unit_price) VALUES ($1,$2,$3,$4,$5,$6) RETURNING id, ticket_id, part_no, model, quantity, unit_price, is_selected
`

type CreateTicketItemParams struct {
	ID        uuid.UUID
	TicketID  uuid.UUID
	PartNo    string
	Model     string
	Quantity  int32
	UnitPrice float64
}

// -------------------------------------------------------------------------------------------------------------------------------
// Mutation-(Ticket Item)
// ---------------------------------------------------------------------------------------------------------------------------------
func (q *Queries) CreateTicketItem(ctx context.Context, arg CreateTicketItemParams) (TicketItem, error) {
	row := q.db.QueryRowContext(ctx, createTicketItem,
		arg.ID,
		arg.TicketID,
		arg.PartNo,
		arg.Model,
		arg.Quantity,
		arg.UnitPrice,
	)
	var i TicketItem
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.PartNo,
		&i.Model,
		&i.Quantity,
		&i.UnitPrice,
		&i.IsSelected,
	)
	return i, err
}

const deletePendingTicketsOlderThan2Days = `-- name: DeletePendingTicketsOlderThan2Days :many
DELETE FROM tickets
WHERE status = 'pending'
  AND created_at < NOW() - INTERVAL '2 days'
RETURNING id, ticket_date, customer_id, daily_number, paf, images_included, status, transport_mode, inspection_images, confirm_order_date, check_for_damage, remove_all_labels, exclude_documents, urgent_requirement, created_at
`

func (q *Queries) DeletePendingTicketsOlderThan2Days(ctx context.Context) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, deletePendingTicketsOlderThan2Days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ticket
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.TicketDate,
			&i.CustomerID,
			&i.DailyNumber,
			&i.Paf,
			&i.ImagesIncluded,
			&i.Status,
			&i.TransportMode,
			pq.Array(&i.InspectionImages),
			&i.ConfirmOrderDate,
			&i.CheckForDamage,
			&i.RemoveAllLabels,
			&i.ExcludeDocuments,
			&i.UrgentRequirement,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteTicketByDateAndDailyNumber = `-- name: DeleteTicketByDateAndDailyNumber :exec
DELETE FROM tickets
WHERE ticket_date::date = $1
  AND daily_number      = $2
`

type DeleteTicketByDateAndDailyNumberParams struct {
	TicketDate  time.Time
	DailyNumber string
}

func (q *Queries) DeleteTicketByDateAndDailyNumber(ctx context.Context, arg DeleteTicketByDateAndDailyNumberParams) error {
	_, err := q.db.ExecContext(ctx, deleteTicketByDateAndDailyNumber, arg.TicketDate, arg.DailyNumber)
	return err
}

const deleteTicketItemsByIds = `-- name: DeleteTicketItemsByIds :many
DELETE FROM ticket_items
WHERE id = ANY($1::uuid[])
RETURNING id, ticket_id, part_no, model, quantity, unit_price, is_selected
`

func (q *Queries) DeleteTicketItemsByIds(ctx context.Context, dollar_1 []uuid.UUID) ([]TicketItem, error) {
	rows, err := q.db.QueryContext(ctx, deleteTicketItemsByIds, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TicketItem
	for rows.Next() {
		var i TicketItem
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.PartNo,
			&i.Model,
			&i.Quantity,
			&i.UnitPrice,
			&i.IsSelected,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteTicketItemsByTicketId = `-- name: DeleteTicketItemsByTicketId :many
DELETE FROM ticket_items
WHERE ticket_id = $1
RETURNING id, ticket_id, part_no, model, quantity, unit_price, is_selected
`

func (q *Queries) DeleteTicketItemsByTicketId(ctx context.Context, ticketID uuid.UUID) ([]TicketItem, error) {
	rows, err := q.db.QueryContext(ctx, deleteTicketItemsByTicketId, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TicketItem
	for rows.Next() {
		var i TicketItem
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.PartNo,
			&i.Model,
			&i.Quantity,
			&i.UnitPrice,
			&i.IsSelected,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterTickets = `-- name: FilterTickets :many



WITH p AS (
  SELECT NULLIF($1::text, '')::date AS d
)
SELECT
  t.id as ticket_id,
  t.ticket_date,
  t.daily_number,
  t.status,
  t.paf,
  t.transport_mode,
  t.inspection_images,
  t.check_for_damage,
  t.remove_all_labels,
  t.exclude_documents,
  t.urgent_requirement,
  t.images_included,
  c.customer_company_name AS customer_company_name,
  c.contact_person AS contact_person,
  c.mobile AS customer_phone,
  c.type as customer_type,
  c.payment_mode as payment_mode,
  i.id as item_id,
  i.part_no,
  i.model,
  i.quantity,
  i.unit_price,
  i.is_selected,
  b.name                     AS brand_name,
  cat.name                   AS category_name
FROM tickets t
LEFT JOIN ticket_items i ON i.ticket_id = t.id
LEFT JOIN customers c   ON c.id = t.customer_id
LEFT JOIN product_parts pp  ON pp.part_no  = i.part_no 
LEFT JOIN brands        b   ON b.id        = pp.brand_id
LEFT JOIN categories    cat ON cat.id      = pp.category_id
CROSS JOIN p
WHERE (p.d IS NULL OR (t.ticket_date >= p.d AND t.ticket_date < p.d + INTERVAL '1 day'))
  AND (NULLIF($2::text,'') IS NULL OR t.daily_number = $2)
  AND (NULLIF($3::text,'') IS NULL OR t.status = $3)
ORDER BY t.ticket_date DESC, t.id, i.id
`

type FilterTicketsParams struct {
	Column1 string
	Column2 string
	Column3 string
}

type FilterTicketsRow struct {
	TicketID            uuid.UUID
	TicketDate          time.Time
	DailyNumber         string
	Status              string
	Paf                 float64
	TransportMode       string
	InspectionImages    []string
	CheckForDamage      sql.NullBool
	RemoveAllLabels     sql.NullBool
	ExcludeDocuments    sql.NullBool
	UrgentRequirement   sql.NullBool
	ImagesIncluded      sql.NullBool
	CustomerCompanyName sql.NullString
	ContactPerson       sql.NullString
	CustomerPhone       sql.NullString
	CustomerType        sql.NullString
	PaymentMode         sql.NullString
	ItemID              uuid.NullUUID
	PartNo              sql.NullString
	Model               sql.NullString
	Quantity            sql.NullInt32
	UnitPrice           sql.NullFloat64
	IsSelected          sql.NullBool
	BrandName           sql.NullString
	CategoryName        sql.NullString
}

// ------------------------------------------------------------------------------------------------------------------------------
// Query (Tickets)
// -----------------------------------------------------------------------------------------------------------------------------
// -- name: FilterTickets :many
// SELECT *
// FROM tickets
// WHERE ($1::date  IS NULL OR ticket_date::date = $1)
//
//	AND ($2::int   IS NULL OR daily_number      = $2)
//	AND ($3::text  IS NULL OR status            = $3)
//
// ORDER BY ticket_date DESC;
func (q *Queries) FilterTickets(ctx context.Context, arg FilterTicketsParams) ([]FilterTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, filterTickets, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterTicketsRow
	for rows.Next() {
		var i FilterTicketsRow
		if err := rows.Scan(
			&i.TicketID,
			&i.TicketDate,
			&i.DailyNumber,
			&i.Status,
			&i.Paf,
			&i.TransportMode,
			pq.Array(&i.InspectionImages),
			&i.CheckForDamage,
			&i.RemoveAllLabels,
			&i.ExcludeDocuments,
			&i.UrgentRequirement,
			&i.ImagesIncluded,
			&i.CustomerCompanyName,
			&i.ContactPerson,
			&i.CustomerPhone,
			&i.CustomerType,
			&i.PaymentMode,
			&i.ItemID,
			&i.PartNo,
			&i.Model,
			&i.Quantity,
			&i.UnitPrice,
			&i.IsSelected,
			&i.BrandName,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonSelectedTicketItemsByTicketId = `-- name: GetNonSelectedTicketItemsByTicketId :many
SELECT id, ticket_id, part_no, model, quantity, unit_price, is_selected
FROM ticket_items
WHERE ticket_id = $1
  AND is_selected = false
`

func (q *Queries) GetNonSelectedTicketItemsByTicketId(ctx context.Context, ticketID uuid.UUID) ([]TicketItem, error) {
	rows, err := q.db.QueryContext(ctx, getNonSelectedTicketItemsByTicketId, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TicketItem
	for rows.Next() {
		var i TicketItem
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.PartNo,
			&i.Model,
			&i.Quantity,
			&i.UnitPrice,
			&i.IsSelected,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketItemByTicketId = `-- name: GetTicketItemByTicketId :many


SELECT id, ticket_id, part_no, model, quantity, unit_price, is_selected FROM ticket_items WHERE ticket_id=$1
`

// -------------------------------------------------------------------------------------------------------------------------------
// Query-(Ticket Item)
// -------------------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetTicketItemByTicketId(ctx context.Context, ticketID uuid.UUID) ([]TicketItem, error) {
	rows, err := q.db.QueryContext(ctx, getTicketItemByTicketId, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TicketItem
	for rows.Next() {
		var i TicketItem
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.PartNo,
			&i.Model,
			&i.Quantity,
			&i.UnitPrice,
			&i.IsSelected,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicket = `-- name: UpdateTicket :one
UPDATE tickets AS t
SET
  status              = COALESCE($1, t.status),
  confirm_order_date  = COALESCE($2, t.confirm_order_date),
  images_included     = COALESCE($3, t.images_included),
  transport_mode      = COALESCE(NULLIF($4, ''), t.transport_mode),
  inspection_images   = COALESCE($5::TEXT[], t.inspection_images),
  check_for_damage    = COALESCE($6, t.check_for_damage),
  remove_all_labels   = COALESCE($7, t.remove_all_labels),
  exclude_documents   = COALESCE($8, t.exclude_documents),
  urgent_requirement  = COALESCE($9, t.urgent_requirement),
  paf                 = COALESCE($10, t.paf) 
WHERE t.ticket_date::date = $11
  AND t.daily_number      = $12
RETURNING id, ticket_date, customer_id, daily_number, paf, images_included, status, transport_mode, inspection_images, confirm_order_date, check_for_damage, remove_all_labels, exclude_documents, urgent_requirement, created_at
`

type UpdateTicketParams struct {
	Status            sql.NullString
	ConfirmOrderDate  sql.NullTime
	ImagesIncluded    sql.NullBool
	TransportMode     interface{}
	InspectionImages  []string
	CheckForDamage    sql.NullBool
	RemoveAllLabels   sql.NullBool
	ExcludeDocuments  sql.NullBool
	UrgentRequirement sql.NullBool
	Paf               sql.NullFloat64
	TicketDate        time.Time
	DailyNumber       string
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicket,
		arg.Status,
		arg.ConfirmOrderDate,
		arg.ImagesIncluded,
		arg.TransportMode,
		pq.Array(arg.InspectionImages),
		arg.CheckForDamage,
		arg.RemoveAllLabels,
		arg.ExcludeDocuments,
		arg.UrgentRequirement,
		arg.Paf,
		arg.TicketDate,
		arg.DailyNumber,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.TicketDate,
		&i.CustomerID,
		&i.DailyNumber,
		&i.Paf,
		&i.ImagesIncluded,
		&i.Status,
		&i.TransportMode,
		pq.Array(&i.InspectionImages),
		&i.ConfirmOrderDate,
		&i.CheckForDamage,
		&i.RemoveAllLabels,
		&i.ExcludeDocuments,
		&i.UrgentRequirement,
		&i.CreatedAt,
	)
	return i, err
}

const updateTicketItem = `-- name: UpdateTicketItem :one
UPDATE ticket_items AS ti SET
  model        = COALESCE($1, ti.model),
  quantity     = COALESCE($2, ti.quantity),
  unit_price   = COALESCE($3, ti.unit_price),
  is_selected  = COALESCE($4, ti.is_selected)
WHERE ti.ticket_id = $5
  AND ti.part_no   = $6
RETURNING id, ticket_id, part_no, model, quantity, unit_price, is_selected
`

type UpdateTicketItemParams struct {
	Model      sql.NullString
	Quantity   sql.NullInt32
	UnitPrice  sql.NullFloat64
	IsSelected sql.NullBool
	TicketID   uuid.UUID
	PartNo     string
}

func (q *Queries) UpdateTicketItem(ctx context.Context, arg UpdateTicketItemParams) (TicketItem, error) {
	row := q.db.QueryRowContext(ctx, updateTicketItem,
		arg.Model,
		arg.Quantity,
		arg.UnitPrice,
		arg.IsSelected,
		arg.TicketID,
		arg.PartNo,
	)
	var i TicketItem
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.PartNo,
		&i.Model,
		&i.Quantity,
		&i.UnitPrice,
		&i.IsSelected,
	)
	return i, err
}
