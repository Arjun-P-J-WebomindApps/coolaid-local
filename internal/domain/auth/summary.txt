D:\Local\coolaid-backend-model\internal\domain\auth\db_models.go
package auth

import "time"

/*
Domain-level representations of DB rows.
These are NOT sqlc / ORM models.
The DB implementation adapts to these.
*/

type UserRow struct {
	ID       ID
	Name     string
	Username string
	Email    string
	Password string
	Mobile   string
	Role     string
	IsActive bool
}

type UserTotpRow struct {
	UserID ID
	Secret string
}

type SessionRow struct {
	SessionID ID
	UserID    ID
	ExpiresAt time.Time
	RevokedAt *time.Time
}

type RefreshTokenRow struct {
	ID        ID
	UserID    ID
	SessionID ID
	TokenHash string
	ExpiresAt time.Time
	RevokedAt *time.Time
	CreatedAt time.Time
}

type OTPRow struct {
	UserID    ID
	OtpCode   string
	ExpiresAt time.Time
	IsUsed    bool
}

D:\Local\coolaid-backend-model\internal\domain\auth\db_params.go
package auth

import "time"

// ---------- USER ----------

type CreateUserParams struct {
	ID        ID
	Name      string
	Username  string
	Email     string
	Password  string
	Mobile    string
	Role      string
	IsActive  bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

// ---------- TOTP ----------

type CreateUserTotpParams struct {
	UserID ID
	Secret string
}

// ---------- SESSION ----------

type CreateSessionParams struct {
	UserID    ID
	SessionID ID
	IP        string
	UserAgent string
	ExpiresAt time.Time
}

// ---------- REFRESH TOKEN ----------

type CreateRefreshTokenParams struct {
	UserID    ID
	SessionID ID
	TokenHash string
	ExpiresAt time.Time
}

// ---------- OTP ----------

type CreateOTPParams struct {
	UserID    ID
	OtpCode   string
	ExpiresAt time.Time
}

D:\Local\coolaid-backend-model\internal\domain\auth\errors.go
package auth

import "errors"

var (
	ErrInvalidCredentials = errors.New("invalid credentials")
	ErrInvalidOTP         = errors.New("invalid otp")
	ErrExpiredOTP         = errors.New("otp expired")

	ErrUserExists   = errors.New("user already exists")
	ErrUnauthorized = errors.New("unauthorized")
	ErrMFARequired  = errors.New("mfa required")

	ErrSessionExpired = errors.New("session expired")
	ErrSessionRevoked = errors.New("session revoked")

	ErrInternal = errors.New("internal error")

	ErrRefreshExpired = errors.New("refresh expired")
)

D:\Local\coolaid-backend-model\internal\domain\auth\inputs.go
package auth

// CreateUserInput is the input required to register a new user.
// This is a domain-level DTO, not a DB model.
type CreateUserInput struct {
	Name     string
	Username string
	Email    string
	Password string
	Mobile   string
	Role     string
}

D:\Local\coolaid-backend-model\internal\domain\auth\interfaces.go
package auth

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/google/uuid"
	"github.com/webomindapps-dev/coolaid-backend/oplog"
)

type ID string

// ToUUID converts an auth.ID into a uuid.UUID with logging support
func (id ID) ToUUID(ctx context.Context) (uuid.UUID, error) {
	u, err := uuid.Parse(string(id))
	if err != nil {
		oplog.Error(ctx,
			"failed to convert auth.ID to uuid",
			"id=", id,
			"error=", err,
		)

		return uuid.Nil, fmt.Errorf("invalid id %q: %w", id, err)
	}

	return u, nil
}

type Queries interface {
	GetUserByEmail(ctx context.Context, email string) (*UserRow, error)
	GetUserByUsername(ctx context.Context, username string) (*UserRow, error)
	GetUserById(ctx context.Context, id ID) (*UserRow, error)

	CreateUser(ctx context.Context, p CreateUserParams) (*UserRow, error)

	GetUserTotpByUserID(ctx context.Context, userID ID) (*UserTotpRow, error)
	CreateUserTotp(ctx context.Context, p CreateUserTotpParams) error

	GetUserSessionByUserId(ctx context.Context, userID ID) (*SessionRow, error)
	GetUserSessionById(ctx context.Context, sessionID ID) (*SessionRow, error)
	CreateUserSession(ctx context.Context, p CreateSessionParams) (*SessionRow, error)
	DeleteUserSession(ctx context.Context, sessionID ID) error

	CreateRefreshToken(ctx context.Context, p CreateRefreshTokenParams) error
	DeleteRefreshTokensBySession(ctx context.Context, sessionID ID) error
	GetRefreshTokenByHash(ctx context.Context, hash string) (*RefreshTokenRow, error)

	CreateOTP(ctx context.Context, p CreateOTPParams) error
	GetLatestOTPFromUser(ctx context.Context, userID ID) (*OTPRow, error)
	DeleteUserOTPByUserId(ctx context.Context, userID ID) error
	MarkOTPAsUsed(ctx context.Context, userID ID) error

	UpdateUserPassword(ctx context.Context, userID ID, hashedPassword string) error
}

type DB interface {
	BeginTx(ctx context.Context) (*sql.Tx, Queries, error)
	Queries() Queries
}

type Crypto interface {
	HashPassword(string) (string, error)
	ComparePassword(plain, hash string) error

	HashToken(string) (string, error)
	CompareToken(hash, plain string) error

	GenerateSecureToken(n int) (string, error)
	GenerateNumericOTP(n int) (string, error)

	GenerateJWT(ctx context.Context, sessionID, userID ID) (string, error)
	ValidateJWT(token string) (*JWTClaims, error)
	ValidateJWTFromContext(ctx context.Context) (*JWTClaims, error)
}

type Mailer interface {
	Send(to, subject, html string) error
}

type CookieWriter interface {
	SetAuth(access, refresh string)
	ClearAuth()
}

D:\Local\coolaid-backend-model\internal\domain\auth\login.go
package auth

import "context"

func (s *Service) Login(ctx context.Context, email, password string) (*AuthResult, error) {
	user, err := s.DB.Queries().GetUserByEmail(ctx, email)
	if err != nil {
		return nil, ErrInvalidCredentials
	}

	if err := s.Crypto.ComparePassword(password, user.Password); err != nil {
		return nil, ErrInvalidCredentials
	}

	return &AuthResult{
		UserID:   user.ID,
		Username: user.Username,
	}, nil
}

D:\Local\coolaid-backend-model\internal\domain\auth\models.go
package auth

import "time"

type AuthResult struct {
	UserID   ID
	Username string
}

type RegisterResult struct {
	UserID     ID
	Username   string
	Email      string
	OtpSecret  string
	OtpAuthURL string
}

type SessionMeta struct {
	IP        string
	UserAgent string
}

type JWTClaims struct {
	SessionID string
	UserID    ID
	ExpiresAt time.Time
}

D:\Local\coolaid-backend-model\internal\domain\auth\password.go
package auth

import (
	"context"
	"fmt"
	"time"

	"github.com/webomindapps-dev/coolaid-backend/internal/assets/mail"
)

func (s *Service) ForgotPassword(ctx context.Context, email string) error {
	user, err := s.DB.Queries().GetUserByEmail(ctx, email)
	if err != nil {
		return nil
	}

	_ = s.DB.Queries().DeleteUserOTPByUserId(ctx, user.ID)

	otp, _ := s.Crypto.GenerateNumericOTP(6)
	hash, _ := s.Crypto.HashToken(fmt.Sprintf("%s", otp))

	_ = s.DB.Queries().CreateOTP(ctx, CreateOTPParams{
		UserID:    user.ID,
		OtpCode:   hash,
		ExpiresAt: time.Now().Add(15 * time.Minute),
	})

	optHTML := mail.ForgotPasswordOTPTemplate(mail.ForgotPasswordOTPEmailData{
		CommonEmailData: mail.CommonEmailData{
			Year: time.Now().Year(),
		},
		OTP: otp,
	})

	s.Mailer.Send(user.Email, "Reset Password", optHTML)
	return nil
}

func (s *Service) ResetPassword(ctx context.Context, email, token, newPass string) error {
	tx, qtx, err := s.DB.BeginTx(ctx)
	if err != nil {
		return ErrInternal
	}
	defer tx.Rollback()

	user, err := qtx.GetUserByEmail(ctx, email)
	if err != nil {
		return ErrInvalidCredentials
	}

	otp, err := qtx.GetLatestOTPFromUser(ctx, user.ID)
	if err != nil || otp.IsUsed || time.Now().After(otp.ExpiresAt) {
		return ErrInvalidOTP
	}

	if err := s.Crypto.CompareToken(otp.OtpCode, token); err != nil {
		return ErrInvalidOTP
	}

	hashed, _ := s.Crypto.HashPassword(newPass)

	_ = qtx.UpdateUserPassword(ctx, user.ID, hashed)
	_ = qtx.MarkOTPAsUsed(ctx, user.ID)
	_ = qtx.DeleteUserOTPByUserId(ctx, user.ID)

	tx.Commit()
	return nil
}

D:\Local\coolaid-backend-model\internal\domain\auth\refresh.go
package auth

import "context"

func (s *Service) RefreshAuth(
	ctx context.Context,
	writer CookieWriter,
	rawRefresh string,
) error {

	hash, _ := s.Crypto.HashToken(rawRefresh)
	rt, err := s.DB.Queries().GetRefreshTokenByHash(ctx, hash)
	if err != nil {
		return ErrUnauthorized
	}

	session, err := s.DB.Queries().GetUserSessionById(ctx, rt.SessionID)
	if err != nil {
		return ErrUnauthorized
	}

	jwt, _ := s.Crypto.GenerateJWT(ctx, session.SessionID, rt.UserID)
	writer.SetAuth(jwt, rawRefresh)

	return nil
}

D:\Local\coolaid-backend-model\internal\domain\auth\register.go
package auth

import (
	"context"
	"time"

	"github.com/pquerna/otp/totp"
)

func (s *Service) Register(ctx context.Context, in CreateUserInput) (*RegisterResult, error) {
	tx, qtx, err := s.DB.BeginTx(ctx)
	if err != nil {
		return nil, ErrInternal
	}
	defer tx.Rollback()

	hashed, err := s.Crypto.HashPassword(in.Password)
	if err != nil {
		return nil, ErrInternal
	}

	user, err := qtx.CreateUser(ctx, CreateUserParams{
		Name:      in.Name,
		Username:  in.Username,
		Email:     in.Email,
		Password:  hashed,
		Mobile:    in.Mobile,
		Role:      in.Role,
		IsActive:  true,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	})
	if err != nil {
		return nil, ErrUserExists
	}

	key, _ := totp.Generate(totp.GenerateOpts{
		Issuer:      "CoolAid",
		AccountName: in.Email,
	})

	errTOTP := qtx.CreateUserTotp(ctx, CreateUserTotpParams{
		UserID: user.ID,
		Secret: key.Secret(),
	})

	if errTOTP != nil {
		return nil, ErrInternal
	}

	tx.Commit()

	return &RegisterResult{
		UserID:     ID(user.ID),
		Username:   user.Username,
		Email:      user.Email,
		OtpSecret:  key.Secret(),
		OtpAuthURL: key.URL(),
	}, nil
}

D:\Local\coolaid-backend-model\internal\domain\auth\service.go
package auth

type Service struct {
	DB     DB
	Crypto Crypto
	Mailer Mailer
}

func NewService(db DB, crypto Crypto, mailer Mailer) *Service {
	return &Service{db, crypto, mailer}
}

D:\Local\coolaid-backend-model\internal\domain\auth\session.go
package auth

import "context"

func (s *Service) CheckUserStatus(
	ctx context.Context,
	writer CookieWriter,
) (*AuthResult, error) {

	claims, err := s.Crypto.ValidateJWTFromContext(ctx)
	if err != nil {
		writer.ClearAuth()
		return nil, nil
	}

	session, err := s.DB.Queries().GetUserSessionById(ctx, ID(claims.SessionID))
	if err != nil {
		writer.ClearAuth()
		return nil, nil
	}

	user, err := s.DB.Queries().GetUserById(ctx, session.UserID)
	if err != nil || !user.IsActive {
		writer.ClearAuth()
		return nil, nil
	}

	return &AuthResult{
		UserID:   user.ID,
		Username: user.Username,
	}, nil
}

func (s *Service) Logout(ctx context.Context, writer CookieWriter) error {
	claims, err := s.Crypto.ValidateJWTFromContext(ctx)
	if err != nil {
		writer.ClearAuth()
		return nil
	}

	_ = s.DB.Queries().DeleteRefreshTokensBySession(ctx, ID(claims.SessionID))
	_ = s.DB.Queries().DeleteUserSession(ctx, ID(claims.SessionID))

	writer.ClearAuth()
	return nil
}

D:\Local\coolaid-backend-model\internal\domain\auth\toptp.go
package auth

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/pquerna/otp/totp"
	"github.com/webomindapps-dev/coolaid-backend/config"
)

func (s *Service) VerifyTOTP(
	ctx context.Context,
	username string,
	code string,
	meta SessionMeta,
	writer CookieWriter,
) (*AuthResult, error) {

	tx, qtx, err := s.DB.BeginTx(ctx)
	if err != nil {
		return nil, ErrInternal
	}
	defer tx.Rollback()

	user, err := qtx.GetUserByUsername(ctx, username)
	if err != nil {
		return nil, ErrInvalidCredentials
	}

	t, err := qtx.GetUserTotpByUserID(ctx, user.ID)
	if err != nil || !totp.Validate(code, t.Secret) {
		return nil, ErrInvalidOTP
	}

	session, err := qtx.GetUserSessionByUserId(ctx, user.ID)
	if err != nil || session.ExpiresAt.Before(time.Now()) {
		if err == nil {
			_ = qtx.DeleteUserSession(ctx, session.SessionID)
		}

		session, err = qtx.CreateUserSession(ctx, CreateSessionParams{
			UserID:    user.ID,
			SessionID: ID(uuid.New().String()),
			UserAgent: meta.UserAgent,
			ExpiresAt: time.Now().Add(24 * time.Hour),
			IP:        "",
		})
		if err != nil {
			return nil, ErrInternal
		}
	}

	_ = qtx.DeleteRefreshTokensBySession(ctx, session.SessionID)

	raw, _ := s.Crypto.GenerateSecureToken(64)
	hash, _ := s.Crypto.HashToken(raw)

	errRefresh := qtx.CreateRefreshToken(ctx, CreateRefreshTokenParams{
		UserID:    user.ID,
		SessionID: session.SessionID,
		TokenHash: hash,
		ExpiresAt: time.Now().Add(time.Duration(config.Auth.RefreshTokenExpiryHours) * time.Hour),
	})

	if errRefresh != nil {
		return nil, ErrRefreshExpired
	}

	jwt, _ := s.Crypto.GenerateJWT(ctx, ID(session.SessionID), ID(user.ID))

	writer.SetAuth(jwt, raw)

	tx.Commit()

	return &AuthResult{
		UserID:   ID(user.ID),
		Username: user.Username,
	}, nil
}

