package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/webomindapps-dev/coolaid-backend/internal/api/graphql/helpers"
	mapping "github.com/webomindapps-dev/coolaid-backend/internal/api/graphql/mappers/master"
	product_mapper "github.com/webomindapps-dev/coolaid-backend/internal/api/graphql/mappers/product"
	"github.com/webomindapps-dev/coolaid-backend/internal/domain/auth"
	"github.com/webomindapps-dev/coolaid-backend/internal/domain/product"
	graphql1 "github.com/webomindapps-dev/coolaid-backend/internal/generated/graphql"
	"github.com/webomindapps-dev/coolaid-backend/internal/generated/graphql/model"
	"github.com/webomindapps-dev/coolaid-backend/internal/shared/ptr"
	"github.com/webomindapps-dev/coolaid-backend/oplog"
)

// GetUserByID is the resolver for the getUserById field.
func (r *queryResolver) GetUserByID(ctx context.Context, id uuid.UUID) (*model.User, error) {
	res, err := r.Resolver.Services.Auth.DB.Queries().GetUserById(ctx, auth.ID(id.String()))

	if err != nil {
		return nil, mapAuthError(err)
	}

	u, err := res.ID.ToUUID(ctx)

	return &model.User{
		ID:       u,
		Name:     res.Name,
		Username: res.Username,
		Email:    res.Email,
		Mobile:   res.Mobile,
		Role:     res.Role,
		IsActive: res.IsActive,
	}, nil
}

// GetLatestOtp is the resolver for the getLatestOTP field.
func (r *queryResolver) GetLatestOtp(ctx context.Context, userID uuid.UUID) (*model.UserOtp, error) {
	row, err := r.Resolver.Services.Auth.DB.Queries().GetLatestOTPFromUser(ctx, auth.ID(userID.String()))
	if err != nil {
		oplog.Error(ctx,
			"GetLatestOtp failed",
			"user_id=", userID.String(),
			"err=", err,
		)
		return nil, mapAuthError(err)
	}

	uid, err := row.UserID.ToUUID(ctx)
	if err != nil {
		oplog.Error(ctx,
			"GetLatestOtp: invalid user UUID returned from DB",
			"user_id=", row.UserID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oid, err := row.UserID.ToUUID(ctx) // if OTP row has ID, else remove this
	if err != nil {
		oplog.Error(ctx,
			"GetLatestOtp: invalid otp UUID returned from DB",
			"otp_id=", row.UserID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"GetLatestOtp success",
		"user_id=", userID.String(),
	)

	return &model.UserOtp{
		ID:      oid, // remove if not in gql model
		UserID:  uid,
		OtpCode: row.OtpCode, // adjust field name if different
	}, nil
}

// GetSessionByUserID is the resolver for the getSessionByUserId field.
func (r *queryResolver) GetSessionByUserID(ctx context.Context, userID uuid.UUID) (*model.UserSession, error) {
	row, err := r.Resolver.Services.Auth.DB.Queries().GetUserSessionById(ctx, auth.ID(userID.String()))
	if err != nil {
		oplog.Error(ctx,
			"GetSessionByUserID failed",
			"user_id=", userID.String(),
			"err=", err,
		)
		return nil, mapAuthError(err)
	}

	sid, err := row.UserID.ToUUID(ctx)
	if err != nil {
		oplog.Error(ctx,
			"GetSessionByUserID: invalid session UUID returned from DB",
			"id=", row.UserID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	uid, err := row.UserID.ToUUID(ctx)
	if err != nil {
		oplog.Error(ctx,
			"GetSessionByUserID: invalid user UUID returned from DB",
			"user_id=", row.UserID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"GetSessionByUserID success",
		"user_id=", userID.String(),
		"session_id=", sid.String(),
	)

	return &model.UserSession{
		SessionID: sid,
		UserID:    uid,
		ExpiresAt: row.ExpiresAt,
	}, nil
}

// GetSessionStatus is the resolver for the getSessionStatus field.
func (r *queryResolver) GetSessionStatus(ctx context.Context, sessionID uuid.UUID) (*model.SessionStatus, error) {
	_, err := r.Resolver.Services.Auth.DB.Queries().GetUserSessionById(ctx, auth.ID(sessionID.String()))
	if err != nil {
		oplog.Error(ctx,
			"GetSessionStatus failed",
			"session_id=", sessionID.String(),
			"err=", err,
		)
		return nil, mapAuthError(err)
	}

	oplog.Info(ctx,
		"GetSessionStatus success",
		"session_id=", sessionID.String(),
	)

	return &model.SessionStatus{
		Valid: true,
	}, nil
}

// GetCompanyListByName is the resolver for the getCompanyListByName field.
func (r *queryResolver) GetCompanyListByName(ctx context.Context, name *string) ([]*model.Company, error) {
	res, err := r.Resolver.Services.Company.ListByName(ctx, name)
	if err != nil {
		oplog.Error(ctx,
			"ListByName failed",
			"entity=", "company",
			"name=", name,
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	companies, err := mapping.CompaniesToGraphQL(res)
	if err != nil {
		oplog.Error(ctx,
			"Company mapping failed ",
			"entity=", "company",
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	return companies, nil
}

// GetModelsListByName is the resolver for the getModelsListByName field.
func (r *queryResolver) GetModelsListByName(ctx context.Context, input model.ModelQueryInput) ([]*model.ModelQuery, error) {
	res, err := r.Resolver.Services.Model.ListByName(ctx, &input.Model, &input.Company) // adjust service call
	if err != nil {
		oplog.Error(ctx,
			"GetModelsListByName failed",
			"input=", input,
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	oplog.Info(ctx,
		"GetModelsListByName success",
		"count=", len(res),
	)

	// If you already have mapping.ModelQueriesToGraphQL(res) use that instead
	out := make([]*model.ModelQuery, 0, len(res))
	for _, m := range res {
		u, errUUID := uuid.Parse(m.ID)

		if errUUID != nil {
			oplog.Error(ctx,
				"GetModelsListByName error",
				"error=", errUUID,
			)
			continue
		}
		out = append(out, &model.ModelQuery{
			ID:      u,
			Company: m.CompanyName,
			Model:   m.Name,
			Image:   m.ImageURL,
		})
	}
	return out, nil
}

// GetCategoryByName is the resolver for the getCategoryByName field.
func (r *queryResolver) GetCategoryByName(ctx context.Context, category string) ([]*string, error) {
	res, err := r.Resolver.Services.Category.DB.Queries().GetCategoriesByName(ctx, category) // adjust
	if err != nil {
		oplog.Error(ctx,
			"GetCategoryByName failed",
			"category=", category,
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	out := make([]*string, 0, len(res))
	for i := range res {
		v := res[i]
		out = append(out, &v.Name)
	}

	oplog.Info(ctx,
		"GetCategoryByName success",
		"query=", category,
		"count=", len(out),
	)

	return out, nil
}

// GetCategoryListByName is the resolver for the getCategoryListByName field.
func (r *queryResolver) GetCategoryListByName(ctx context.Context, category string) ([]*model.Category, error) {
	res, err := r.Resolver.Services.Category.ListByName(ctx, category) // adjust
	if err != nil {
		oplog.Error(ctx,
			"GetCategoryListByName failed",
			"category=", category,
			"err=", err,
		)
		return nil, err
	}

	oplog.Info(ctx,
		"GetCategoryListByName success",
		"query=", category,
		"count=", len(res),
	)

	out := make([]*model.Category, 0, len(res))
	for _, c := range res {
		u, errUUID := uuid.Parse(c.ID)

		if errUUID != nil {
			oplog.Error(ctx, "GetCategoryList error", "query=", category, "err", errUUID)
			continue
		}
		out = append(out, &model.Category{
			ID:    u,
			Name:  c.Name,
			Image: *c.Image,
		})
	}

	return out, nil
}

// GetBrandListByName is the resolver for the getBrandListByName field.
func (r *queryResolver) GetBrandListByName(ctx context.Context, brand string) ([]*model.Brand, error) {
	res, err := r.Resolver.Services.Brand.ListByName(ctx, &brand)
	if err != nil {
		oplog.Error(ctx,
			"GetBrandListByName failed",
			"brand=", brand,
			"err=", err,
		)
		return nil, err
	}

	oplog.Info(ctx,
		"GetBrandListByName success",
		"query=", brand,
		"count=", len(res),
	)

	out := make([]*model.Brand, 0, len(res))
	for _, b := range res {
		u, errUUID := uuid.Parse(b.ID)

		if errUUID != nil {
			oplog.Error(ctx, "GetBrandListByName", "error=", errUUID)
			continue
		}
		out = append(out, &model.Brand{
			ID:    u,
			Name:  b.Name,
			Image: b.Image,
		})
	}

	return out, nil
}

// GetTypeListByName is the resolver for the getTypeListByName field.
func (r *queryResolver) GetTypeListByName(ctx context.Context, input model.TypeSelectionInput) ([]string, error) {
	panic(fmt.Errorf("not implemented: GetTypeListByName - getTypeListByName"))
}

// GetCustomerByID is the resolver for the getCustomerById field.
func (r *queryResolver) GetCustomerByID(ctx context.Context, customerID uuid.UUID) (*model.Customer, error) {
	res, err := r.Resolver.Services.Customer.GetByID(ctx, customerID.String()) // adjust
	if err != nil {
		oplog.Error(ctx,
			"GetCustomerByID failed",
			"customer_id=", customerID.String(),
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"GetCustomerByID: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"GetCustomerByID success",
		"customer_id=", res.ID,
	)

	return &model.Customer{
		ID:                  u,
		CustomerCompanyName: res.CustomerCompanyName,
		ContactPerson:       res.ContactPerson,
		Mobile:              res.Mobile,
		Type:                res.Type,
		CustomerDesignation: &res.CustomerDesignation,
		Address:             *res.Address,
		Flat:                *res.Flat,
		Street:              *res.Street,
		City:                res.City,
		State:               res.State,
		Pincode:             *res.Pincode,
		PaymentMode:         res.PaymentMode,
	}, nil
}

// GetCustomersByAttributes is the resolver for the getCustomersByAttributes field.
func (r *queryResolver) GetCustomersByAttributes(ctx context.Context, customerCompanyName *string, contactPerson *string, mobile *string) ([]*model.Customer, error) {

	customerCompany := ptr.String(customerCompanyName)
	contact := ptr.String(contactPerson)
	mobileNo := ptr.String(mobile)

	res, err := r.Resolver.Services.Customer.Search(ctx, &customerCompany, &contact, &mobileNo)
	if err != nil {
		oplog.Error(ctx,
			"GetCustomersByAttributes failed",
			"customer_company_name=", customerCompanyName,
			"contact_person=", contactPerson,
			"mobile=", mobile,
			"err=", err,
		)
		return nil, err
	}

	out := make([]*model.Customer, 0, len(res))

	for _, c := range res {
		u, err := uuid.Parse(c.ID)
		if err != nil {
			oplog.Error(ctx,
				"GetCustomersByAttributes: invalid UUID returned from domain",
				"id=", c.ID,
				"err=", err,
			)
			return nil, gqlerror.Errorf("internal error")
		}

		out = append(out, &model.Customer{
			ID:                  u,
			CustomerCompanyName: c.CustomerCompanyName,
			ContactPerson:       c.ContactPerson,
			Mobile:              c.Mobile,
			Type:                c.Type,

			CustomerDesignation: ptr.StringPtr(&c.CustomerDesignation),

			Address:     ptr.String(c.Address),
			Flat:        ptr.String(c.Flat),
			Street:      ptr.String(c.Street),
			City:        c.City,
			State:       c.State,
			Pincode:     ptr.String(c.Pincode),
			PaymentMode: c.PaymentMode,
		})

	}

	oplog.Info(ctx,
		"GetCustomersByAttributes success",
		"count=", len(out),
	)

	return out, nil
}

// GetVendors is the resolver for the getVendors field.
func (r *queryResolver) GetVendors(ctx context.Context, name *string) ([]*model.Vendor, error) {
	res, err := r.Resolver.Services.Vendor.List(ctx, name) // adjust
	if err != nil {
		oplog.Error(ctx,
			"GetVendors failed",
			"name=", name,
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	out := make([]*model.Vendor, 0, len(res))

	for _, v := range res {
		uid, err := uuid.Parse(v.ID)
		if err != nil {
			oplog.Error(ctx,
				"GetVendors: invalid UUID returned from domain",
				"id=", v.ID,
				"err=", err,
			)
			return nil, gqlerror.Errorf("internal error")
		}

		contacts := make([]*model.VendorContact, 0, len(v.VendorContacts))

		for _, contact := range v.VendorContacts {

			contacts = append(contacts, &model.VendorContact{
				ContactPerson: contact.ContactPerson,
				MobileNumber:  contact.MobileNumber,
				EmailID:       contact.EmailID,
			})
		}

		out = append(out, &model.Vendor{
			ID:             uid,
			CompanyName:    v.CompanyName,
			VendorContacts: contacts,
			// If your gql Vendor includes contacts, map them here too.
		})
	}

	oplog.Info(ctx,
		"GetVendors success",
		"name=", name,
		"count=", len(out),
	)

	return out, nil
}

// GetFilteredPartNo is the resolver for the getFilteredPartNo field.
// GetFilteredPartNo resolves the getFilteredPartNo query.
func (r *queryResolver) GetFilteredPartNo(
	ctx context.Context,
	partNo *string,
) ([]string, error) {

	if partNo == nil || *partNo == "" {
		return nil, gqlerror.Errorf("part number is required")
	}

	rows, err := r.Services.Product.GetProductPartNos(ctx, *partNo)
	if err != nil {
		return nil, mapProductError(err)
	}

	return rows, nil
}

// GetFilteredParts is the resolver for the getFilteredParts field.
// GetFilteredParts resolves the getFilteredParts query.
func (r *queryResolver) GetFilteredParts(
	ctx context.Context,
	filter model.FilterInput,
) (*model.FilteredResponse, error) {

	selfSubFields := helpers.GetRequestedSubFields(ctx, "self")
	unicodeSubFields := helpers.GetRequestedSubFields(ctx, "unicode")

	filteredResp, err := r.Services.Product.GetFilterPageDetails(
		ctx,
		product.FilterSelectionParams{
			Company:  filter.CompanyName,
			Model:    filter.ModelName,
			Category: filter.CategoryName,
			Brand:    filter.BrandName,
			Unicode:  filter.Unicode,
		},
		selfSubFields,
		unicodeSubFields,
	)
	if err != nil {
		return nil, mapProductError(err)
	}

	self := make([]*model.FilterOrigin, 0, len(filteredResp.Self))
	for _, item := range filteredResp.Self {
		self = append(self, product_mapper.ToFilterOrigin(item))
	}

	unicode := make([]*model.FilterOrigin, 0, len(filteredResp.Unicode))
	for _, item := range filteredResp.Unicode {
		unicode = append(unicode, product_mapper.ToFilterOrigin(item))
	}

	return &model.FilteredResponse{
		Self:    self,
		Unicode: unicode,
	}, nil
}

// GetProductPartNo is the resolver for the getProductPartNo field.
func (r *queryResolver) GetProductPartNo(ctx context.Context, partNo string) ([]string, error) {
	parts, err := r.Services.Product.GetProductPartNos(ctx, partNo)

	if err != nil {
		return []string{}, mapProductError(err)
	}

	return parts, nil
}

// GetProductDetails is the resolver for the getProductDetails field.
func (r *queryResolver) GetProductDetails(ctx context.Context, productDetails model.ProductDetailsInput) ([]*model.ProductDetails, error) {
	parts, err := r.Services.Product.ListProducts(ctx, product.ProductsFilterParams{
		Company:           productDetails.Company,
		Model:             productDetails.Model,
		Categories:        productDetails.Categories,
		Brands:            productDetails.Brands,
		PartNo:            productDetails.PartNo,
		Gen:               productDetails.Gen,
		FuelType:          productDetails.FuelType,
		Mark:              productDetails.Mark,
		UnicodeCategories: productDetails.UnicodeCategories,
	})

	if err != nil {
		return []*model.ProductDetails{}, mapProductError(err)
	}

	return product_mapper.MapProductList(ctx, parts), nil
}

// GetSimilarPricing is the resolver for the getSimilarPricing field.
func (r *queryResolver) GetSimilarPricing(ctx context.Context, input *model.SimilarPricingInput) ([]*model.SimilarPricing, error) {
	panic(fmt.Errorf("not implemented: GetSimilarPricing - getSimilarPricing"))
}

// GetTicketDetails is the resolver for the getTicketDetails field.
func (r *queryResolver) GetTicketDetails(ctx context.Context, input *model.FilterTicketInput) ([]*model.OrderTicket, error) {
	panic(fmt.Errorf("not implemented: GetTicketDetails - getTicketDetails"))
}

// GetOutOfStockList is the resolver for the getOutOfStockList field.
func (r *queryResolver) GetOutOfStockList(ctx context.Context) ([]*model.OutOfStockItem, error) {
	panic(fmt.Errorf("not implemented: GetOutOfStockList - getOutOfStockList"))
}

// GetPlacedOrders is the resolver for the getPlacedOrders field.
func (r *queryResolver) GetPlacedOrders(ctx context.Context) ([]*model.RestockOrdersByDate, error) {
	panic(fmt.Errorf("not implemented: GetPlacedOrders - getPlacedOrders"))
}

// GetActuatorByPartNo is the resolver for the getActuatorByPartNo field.
func (r *queryResolver) GetActuatorByPartNo(ctx context.Context, partNo string) (*model.Actuator, error) {
	row, err := r.Services.TechSpec.GetActuator(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Actuator{
		ID:            uid,
		PartNo:        row.PartNo,
		ConnectorType: row.ConnectorType,
		Mounting:      row.Mounting,
		Voltage:       row.Voltage,
		RotationAngle: row.RotationAngle,
		Notes:         row.Notes,
	}, nil
}

// GetBlowerMotorByPartNo is the resolver for the getBlowerMotorByPartNo field.
func (r *queryResolver) GetBlowerMotorByPartNo(ctx context.Context, partNo string) (*model.BlowerMotor, error) {

	row, err := r.Services.TechSpec.GetBlowerMotor(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.BlowerMotor{
		ID:            uid,
		PartNo:        row.PartNo,
		Mounting:      row.Mounting,
		ConnectorType: row.ConnectorType,
		Impeller:      row.Impeller,
		Resistance:    row.Resistance,
		MotorMounting: row.MotorMounting,
		MotorType:     row.MotorType,
		Voltage:       row.Voltage,
		Notes:         row.Notes,
	}, nil
}

// GetCabinFilterByPartNo is the resolver for the getCabinFilterByPartNo field.
func (r *queryResolver) GetCabinFilterByPartNo(ctx context.Context, partNo string) (*model.CabinFilter, error) {
	row, err := r.Services.TechSpec.GetCabinFilter(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.CabinFilter{
		ID:         uid,
		PartNo:     row.PartNo,
		Type:       row.Type,
		Dimensions: row.Dimensions,
		Material:   row.Material,
		Notes:      row.Notes,
	}, nil
}

// GetChillerUnitByPartNo is the resolver for the getChillerUnitByPartNo field.
func (r *queryResolver) GetChillerUnitByPartNo(ctx context.Context, partNo string) (*model.ChillerUnit, error) {

	row, err := r.Services.TechSpec.GetChillerUnit(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.ChillerUnit{
		ID:      uid,
		PartNo:  row.PartNo,
		Type:    row.Type,
		Voltage: row.Voltage,
		Notes:   row.Notes,
	}, nil
}

// GetClutchAssyByPartNo is the resolver for the getClutchAssyByPartNo field.
func (r *queryResolver) GetClutchAssyByPartNo(ctx context.Context, partNo string) (*model.ClutchAssy, error) {

	row, err := r.Services.TechSpec.GetClutchAssy(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.ClutchAssy{
		ID:                uid,
		PartNo:            row.PartNo,
		PulleyRibs:        row.PulleyRibs,
		PulleySize:        row.PulleySize,
		CompressorDetails: row.CompressorDetails,
		ConnectorType:     row.ConnectorType,
		Voltage:           row.Voltage,
		ShaftType:         row.ShaftType,
		Notes:             row.Notes,
	}, nil
}

// GetCompressorValveByPartNo is the resolver for the getCompressorValveByPartNo field.
func (r *queryResolver) GetCompressorValveByPartNo(ctx context.Context, partNo string) (*model.CompressorValve, error) {
	row, err := r.Services.TechSpec.GetCompressorValve(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.CompressorValve{
		ID:                uid,
		PartNo:            row.PartNo,
		Type:              row.Type,
		Voltage:           row.Voltage,
		ConnectorType:     row.ConnectorType,
		CompressorDetails: row.CompressorDetails,
		Notes:             row.Notes,
	}, nil
}

// GetCondFanAssyByPartNo is the resolver for the getCondFanAssyByPartNo field.
func (r *queryResolver) GetCondFanAssyByPartNo(ctx context.Context, partNo string) (*model.CondFanAssy, error) {
	row, err := r.Services.TechSpec.GetCondFanAssy(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.CondFanAssy{
		ID:               uid,
		PartNo:           row.PartNo,
		Voltage:          row.Voltage,
		MotorType:        row.MotorType,
		Resistance:       row.Resistance,
		FanBladeDiameter: row.FanBladeDiameter,
		NumberOfBlades:   row.NumberOfBlades,
		Shroud:           row.Shroud,
		ConnectorType:    row.ConnectorType,
		Notes:            row.Notes,
	}, nil
}

// GetCondenserByPartNo is the resolver for the getCondenserByPartNo field.
func (r *queryResolver) GetCondenserByPartNo(ctx context.Context, partNo string) (*model.Condenser, error) {
	row, err := r.Services.TechSpec.GetCondenser(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Condenser{
		ID:             uid,
		PartNo:         row.PartNo,
		Size:           row.Size,
		PipeConnector:  row.PipeConnector,
		Drier:          row.Drier,
		PressureSwitch: row.PressureSwitch,
		Notes:          row.Notes,
	}, nil
}

func (r *queryResolver) GetEvaporatorByPartNo(ctx context.Context, partNo string) (*model.Evaporator, error) {
	row, err := r.Services.TechSpec.GetEvaporator(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Evaporator{
		ID:             uid,
		PartNo:         row.PartNo,
		Mounting:       row.Mounting,
		ExpValve:       row.ExpValve,
		AdditionalInfo: row.AdditionalInfo,
		Dimensions:     row.Dimensions,
		PipeConnector:  row.PipeConnector,
		Notes:          row.Notes,
	}, nil
}

// GetExpansionValveByPartNo is the resolver for the getExpansionValveByPartNo field.
func (r *queryResolver) GetExpansionValveByPartNo(ctx context.Context, partNo string) (*model.ExpansionValve, error) {
	row, err := r.Services.TechSpec.GetExpansionValve(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.ExpansionValve{
		ID:          uid,
		PartNo:      row.PartNo,
		Type:        row.Type,
		Material:    row.Material,
		Refrigerant: row.Refrigerant,
		Notes:       row.Notes,
	}, nil
}

// GetFilterDrierByPartNo is the resolver for the getFilterDrierByPartNo field.
func (r *queryResolver) GetFilterDrierByPartNo(ctx context.Context, partNo string) (*model.FilterDrier, error) {
	row, err := r.Services.TechSpec.GetFilterDrier(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.FilterDrier{
		ID:             uid,
		PartNo:         row.PartNo,
		PipeConnector:  row.PipeConnector,
		Size:           row.Size,
		PressureSwitch: row.PressureSwitch,
		Notes:          row.Notes,
	}, nil
}

// GetHeaterCoreByPartNo is the resolver for the getHeaterCoreByPartNo field.
func (r *queryResolver) GetHeaterCoreByPartNo(ctx context.Context, partNo string) (*model.HeaterCore, error) {
	row, err := r.Services.TechSpec.GetHeaterCore(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.HeaterCore{
		ID:     uid,
		PartNo: row.PartNo,
		Size:   row.Size,
		Pipe:   row.Pipe,
		Type:   row.Type,
		Notes:  row.Notes,
	}, nil
}

// GetIntercoolerByPartNo is the resolver for the getIntercoolerByPartNo field.
func (r *queryResolver) GetIntercoolerByPartNo(ctx context.Context, partNo string) (*model.Intercooler, error) {
	row, err := r.Services.TechSpec.GetIntercooler(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Intercooler{
		ID:         uid,
		PartNo:     row.PartNo,
		Size:       row.Size,
		TempSensor: row.TempSensor,
		Notes:      row.Notes,
	}, nil
}

// GetPressureSwitchByPartNo is the resolver for the getPressureSwitchByPartNo field.
func (r *queryResolver) GetPressureSwitchByPartNo(ctx context.Context, partNo string) (*model.PressureSwitch, error) {
	row, err := r.Services.TechSpec.GetPressureSwitch(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.PressureSwitch{
		ID:            uid,
		PartNo:        row.PartNo,
		ConnectorType: row.ConnectorType,
		ThreadType:    row.ThreadType,
		Notes:         row.Notes,
	}, nil
}

// GetRadiatorByPartNo is the resolver for the getRadiatorByPartNo field.
func (r *queryResolver) GetRadiatorByPartNo(ctx context.Context, partNo string) (*model.Radiator, error) {
	row, err := r.Services.TechSpec.GetRadiator(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Radiator{
		ID:           uid,
		PartNo:       row.PartNo,
		Size:         row.Size,
		Transmission: row.Transmission,
		TempSensor:   row.TempSensor,
		Tank:         row.Tank,
		Notes:        row.Notes,
	}, nil
}

// GetRadFanAssyByPartNo is the resolver for the getRadFanAssyByPartNo field.
func (r *queryResolver) GetRadFanAssyByPartNo(ctx context.Context, partNo string) (*model.RadFanAssy, error) {
	row, err := r.Services.TechSpec.GetRadFanAssy(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.RadFanAssy{
		ID:               uid,
		PartNo:           row.PartNo,
		Voltage:          row.Voltage,
		MotorType:        row.MotorType,
		Resistance:       row.Resistance,
		NumberOfSockets:  row.NumberOfSockets,
		Shroud:           row.Shroud,
		ConnectorType:    row.ConnectorType,
		FanBladeDiameter: row.FanBladeDiameter,
		NumberOfBlades:   row.NumberOfBlades,
		Notes:            row.Notes,
	}, nil
}

// GetRadFanMotorByPartNo is the resolver for the getRadFanMotorByPartNo field.
func (r *queryResolver) GetRadFanMotorByPartNo(ctx context.Context, partNo string) (*model.RadFanMotor, error) {
	row, err := r.Services.TechSpec.GetRadFanMotor(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.RadFanMotor{
		ID:               uid,
		PartNo:           row.PartNo,
		FanBladeDiameter: row.FanBladeDiameter,
		NumberOfBlades:   row.NumberOfBlades,
		Voltage:          row.Voltage,
		NumberOfSockets:  row.NumberOfSockets,
		ConnectorType:    row.ConnectorType,
		Notes:            row.Notes,
	}, nil
}

// GetResistorByPartNo is the resolver for the getResistorByPartNo field.
func (r *queryResolver) GetResistorByPartNo(ctx context.Context, partNo string) (*model.Resistor, error) {
	row, err := r.Services.TechSpec.GetResistor(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Resistor{
		ID:            uid,
		PartNo:        row.PartNo,
		Type:          row.Type,
		ConnectorType: row.ConnectorType,
		Voltage:       row.Voltage,
		Notes:         row.Notes,
	}, nil
}

// GetRotorByPartNo is the resolver for the getRotorByPartNo field.
func (r *queryResolver) GetRotorByPartNo(ctx context.Context, partNo string) (*model.Rotor, error) {
	row, err := r.Services.TechSpec.GetRotor(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Rotor{
		ID:                uid,
		PartNo:            row.PartNo,
		PulleyRibs:        row.PulleyRibs,
		PulleySize:        row.PulleySize,
		CompressorDetails: row.CompressorDetails,
		Notes:             row.Notes,
	}, nil
}

// GetStatorByPartNo is the resolver for the getStatorByPartNo field.
func (r *queryResolver) GetStatorByPartNo(ctx context.Context, partNo string) (*model.Stator, error) {
	row, err := r.Services.TechSpec.GetStator(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Stator{
		ID:                uid,
		PartNo:            row.PartNo,
		Voltage:           row.Voltage,
		CompressorDetails: row.CompressorDetails,
		Notes:             row.Notes,
	}, nil
}

// GetCompressorByPartNo is the resolver for the getCompressorByPartNo field.
func (r *queryResolver) GetCompressorByPartNo(ctx context.Context, partNo string) (*model.Compressor, error) {
	row, err := r.Services.TechSpec.GetCompressor(ctx, partNo)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	uid, err := helpers.ParseUUIDOrInternal(row.ID)
	if err != nil {
		return nil, mapTechSpecError(err)
	}

	return &model.Compressor{
		ID:            uid,
		PartNo:        row.PartNo,
		CompressorID:  row.CompressorID,
		Oil:           row.Oil,
		Refrigerant:   row.Refrigerant,
		Voltage:       row.Voltage,
		PulleyRibs:    row.PulleyRibs,
		PulleySize:    row.PulleySize,
		PipeConnector: row.PipeConnector,
		CompType:      row.CompType,
		CompMounting:  row.CompMounting,
		ConnectorType: row.ConnectorType,
		Notes:         row.Notes,
	}, nil
}

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
