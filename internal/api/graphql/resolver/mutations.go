package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/webomindapps-dev/coolaid-backend/config"
	"github.com/webomindapps-dev/coolaid-backend/internal/domain/auth"
	brand "github.com/webomindapps-dev/coolaid-backend/internal/domain/master/brands"
	"github.com/webomindapps-dev/coolaid-backend/internal/domain/master/category"
	"github.com/webomindapps-dev/coolaid-backend/internal/domain/master/company"
	"github.com/webomindapps-dev/coolaid-backend/internal/domain/master/customer"
	models "github.com/webomindapps-dev/coolaid-backend/internal/domain/master/model"
	vendor "github.com/webomindapps-dev/coolaid-backend/internal/domain/master/vendors"
	graphql1 "github.com/webomindapps-dev/coolaid-backend/internal/generated/graphql"
	"github.com/webomindapps-dev/coolaid-backend/internal/generated/graphql/model"
	"github.com/webomindapps-dev/coolaid-backend/oplog"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	res, err := r.Resolver.Services.Auth.Login(ctx, input.Email, input.Password)
	if err != nil {
		return nil, mapAuthError(err)
	}

	return &model.AuthPayload{
		UserName: res.Username,
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.CreateUserPayload, error) {
	res, err := r.Resolver.Services.Auth.Register(ctx, auth.CreateUserInput{
		Name:     input.Name,
		Username: input.Username,
		Email:    input.Email,
		Password: input.Password,
		Mobile:   input.Mobile,
		Role:     input.Role,
	})
	if err != nil {
		return nil, mapAuthError(err)
	}

	return &model.CreateUserPayload{
		User: &model.User{
			Name: res.Username,
		},
		Secret:     res.OtpSecret,
		OtpauthURL: res.OtpAuthURL,
	}, nil
}

// VerifyTotp is the resolver for the verifyTOTP field.
func (r *mutationResolver) VerifyTotp(ctx context.Context, input model.VerifyUserTOTPInput) (*model.AuthPayload, error) {
	writer, ok := cookieWriterFromContext(ctx)
	if !ok {
		return nil, mapAuthError(auth.ErrInternal)
	}

	ginCtx, ok := ctx.Value(config.GinContextKey).(*gin.Context)
	if !ok {
		return nil, mapAuthError(auth.ErrInternal)
	}

	res, err := r.Resolver.Services.Auth.VerifyTOTP(
		ctx,
		input.TwoFactorToken, // âœ… username / identifier
		input.OtpCode,
		auth.SessionMeta{
			IP:        ginCtx.ClientIP(),
			UserAgent: ginCtx.Request.UserAgent(),
		},
		writer,
	)
	if err != nil {
		return nil, mapAuthError(err)
	}

	return &model.AuthPayload{
		UserName: res.Username,
	}, nil
}

// CheckUserStatus is the resolver for the checkUserStatus field.
func (r *mutationResolver) CheckUserStatus(ctx context.Context) (*model.AuthPayload, error) {
	writer, ok := cookieWriterFromContext(ctx)
	if !ok {
		return nil, mapAuthError(auth.ErrInternal)
	}

	res, err := r.Resolver.Services.Auth.CheckUserStatus(ctx, writer)
	if err != nil || res == nil {
		return nil, nil
	}

	return &model.AuthPayload{
		UserName: res.Username,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, username string) (bool, error) {
	writer, ok := cookieWriterFromContext(ctx)
	if !ok {
		return false, mapAuthError(auth.ErrInternal)
	}

	if err := r.Resolver.Services.Auth.Logout(ctx, writer); err != nil {
		return false, mapAuthError(err)
	}

	return true, nil
}

// ForgotPassword is the resolver for the forgotPassword field.
func (r *mutationResolver) ForgotPassword(ctx context.Context, input model.ForgotPasswordInput) (bool, error) {
	if err := r.Resolver.Services.Auth.ForgotPassword(
		ctx,
		input.Email,
	); err != nil {
		return false, mapAuthError(err)
	}

	// Always return true (security best practice)
	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, input model.ResetPasswordInput) (bool, error) {
	if err := r.Resolver.Services.Auth.ResetPassword(
		ctx,
		input.Email,
		input.Token,
		input.NewPassword,
	); err != nil {
		return false, mapAuthError(err)
	}

	return true, nil
}

// RefreshAuth is the resolver for the refreshAuth field.
func (r *mutationResolver) RefreshAuth(ctx context.Context) (bool, error) {
	writer, ok := cookieWriterFromContext(ctx)
	if !ok {
		return false, mapAuthError(auth.ErrInternal)
	}

	// raw refresh token should come from cookie middleware
	rawRefresh := ctx.Value("refresh_token").(string)

	if err := r.Resolver.Services.Auth.RefreshAuth(
		ctx,
		writer,
		rawRefresh,
	); err != nil {
		return false, mapAuthError(err)
	}

	return true, nil
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input model.CreateCompanyInput) (*model.Company, error) {
	res, err := r.Resolver.Services.Company.Create(ctx, company.CreateCompanyInput{
		Name:     input.Name,
		Status:   input.Status,
		ImageURL: input.Image,
	})
	if err != nil {
		oplog.Error(ctx,
			"CreateCompany failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"CreateCompany: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Company created",
		"company_id=", res.ID,
		"name=", res.Name,
	)

	return &model.Company{
		ID:     u,
		Name:   res.Name,
		Status: res.Status,
		Image:  res.ImageURL,
	}, nil
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, input model.UpdateCompanyInput) (*model.Company, error) {
	res, err := r.Resolver.Services.Company.Update(ctx, company.UpdateCompanyInput{
		Name:     &input.Name,
		Status:   &input.Status,
		ImageURL: &input.Image,
	})

	if err != nil {
		oplog.Error(ctx,
			"UpdateCompany failed",
			"company_id=", input.ID,
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"UpdateCompany: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Company updated",
		"company_id=", res.ID,
		"name=", res.Name,
	)

	return &model.Company{
		ID:     u,
		Name:   res.Name,
		Status: res.Status,
		Image:  res.ImageURL,
	}, nil
}

// CreateModel is the resolver for the createModel field.
func (r *mutationResolver) CreateModel(ctx context.Context, input model.CreateModelInput) (*model.Model, error) {
	res, err := r.Resolver.Services.Model.Create(ctx, models.CreateModelInput{
		CompanyName: input.CompanyName,
		Name:        input.Name,
		ImageURL:    input.Image,
	})

	if err != nil {
		oplog.Error(ctx,
			"CreateModel failed",
			"company_name=", input.CompanyName,
			"name=", input.Name,
			"err=", err,
		)
		return nil, mapModelError(err)
	}

	modelID, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"CreateModel: invalid model UUID from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	companyID, err := uuid.Parse(res.CompanyID)
	if err != nil {
		oplog.Error(ctx,
			"CreateModel: invalid company UUID from domain",
			"company_id=", res.CompanyID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Model created",
		"model_id=", res.ID,
		"company_id=", res.CompanyID,
		"name=", res.Name,
	)

	return &model.Model{
		ID:        modelID,
		CompanyID: companyID,
		Name:      res.Name,
		Image:     res.ImageURL,
	}, nil
}

// UpdateModel is the resolver for the updateModel field.
func (r *mutationResolver) UpdateModel(ctx context.Context, input model.UpdateModelInput) (*model.Model, error) {
	res, err := r.Resolver.Services.Model.Update(ctx, models.UpdateModelInput{
		CompanyName: &input.CompanyName,
		Name:        &input.Name,
		ImageURL:    &input.Image,
	})

	if err != nil {
		oplog.Error(ctx,
			"UpdateModel failed",
			"company_name=", input.CompanyName,
			"name=", input.Name,
			"err=", err,
		)
		return nil, mapModelError(err)
	}

	modelID, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"UpdateModel: invalid model UUID from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	companyID, err := uuid.Parse(res.CompanyID)
	if err != nil {
		oplog.Error(ctx,
			"CreateModel: invalid company UUID from domain",
			"company_id=", res.CompanyID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Model created",
		"model_id=", res.ID,
		"company_id=", res.CompanyID,
		"name=", res.Name,
	)

	return &model.Model{
		ID:        modelID,
		CompanyID: companyID,
		Name:      res.Name,
		Image:     res.ImageURL,
	}, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*model.Category, error) {
	res, err := r.Resolver.Services.Category.Create(ctx, category.CreateCategoryInput{
		Name:  input.Name,
		Image: &input.Image,
	})
	if err != nil {
		oplog.Error(ctx,
			"CreateCategory failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"CreateCategory: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Catgeory created",
		"category_id=", res.ID,
		"name=", res.Name,
	)

	return &model.Category{
		ID:    u,
		Name:  res.Name,
		Image: *res.Image,
	}, nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, input model.UpdateCategoryInput) (*model.Category, error) {
	res, err := r.Resolver.Services.Category.Update(ctx, category.UpdateCategoryInput{
		ID:    input.ID.String(),
		Name:  &input.Name,
		Image: &input.Image,
	})
	if err != nil {
		oplog.Error(ctx,
			"UpdateCategory failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"UpdateCategory: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Category updated",
		"category_id=", res.ID,
		"name=", res.Name,
	)

	return &model.Category{
		ID:    u,
		Name:  res.Name,
		Image: *res.Image,
	}, nil
}

// CreateBrand is the resolver for the createBrand field.
func (r *mutationResolver) CreateBrand(ctx context.Context, input model.CreateBrandInput) (*model.Brand, error) {
	res, err := r.Resolver.Services.Brand.Create(ctx, brand.CreateBrandInput{
		Name:  input.Name,
		Image: *input.Image,
	})
	if err != nil {
		oplog.Error(ctx,
			"CreateBrand failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"CreateBrand: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Brand created",
		"brand_id=", res.ID,
		"name=", res.Name,
	)

	return &model.Brand{
		ID:    u,
		Name:  res.Name,
		Image: res.Image,
	}, nil
}

// UpdateBrand is the resolver for the updateBrand field.
func (r *mutationResolver) UpdateBrand(ctx context.Context, input model.UpdateBrandInput) (*model.Brand, error) {
	res, err := r.Resolver.Services.Brand.Update(ctx, brand.UpdateBrandInput{
		ID:    input.ID.String(),
		Name:  &input.Name,
		Image: &input.Image,
	})
	if err != nil {
		oplog.Error(ctx,
			"UpdateBrand failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"UpdateBrand: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Brand updated",
		"brand_id=", res.ID,
		"name=", res.Name,
	)

	return &model.Brand{
		ID:    u,
		Name:  res.Name,
		Image: res.Image,
	}, nil
}

// CreateCustomer is the resolver for the createCustomer field.
func (r *mutationResolver) CreateCustomer(ctx context.Context, input model.CreateCustomerInput) (*model.Customer, error) {
	res, err := r.Resolver.Services.Customer.Create(ctx, customer.CreateCustomerInput{
		CustomerCompanyName: input.CustomerCompanyName,
		ContactPerson:       input.ContactPerson,
		Mobile:              input.Mobile,
		Type:                input.Type,
		CustomerDesignation: &input.CustomerDesignation,
		Address:             &input.Address,
		Flat:                &input.Flat,
		Street:              &input.Street,
		City:                &input.City,
		State:               &input.State,
		Pincode:             &input.Pincode,
		PaymentMode:         &input.PaymentMode,
	})
	if err != nil {
		oplog.Error(ctx,
			"CreateCustomer failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"CreateCustomer: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Customer created",
		"customer_id=", res.ID,
		"name=", res.ContactPerson,
	)

	return &model.Customer{
		ID:                  u,
		CustomerCompanyName: res.CustomerCompanyName,
		ContactPerson:       res.ContactPerson,
		Mobile:              res.Mobile,
		Type:                res.Type,
		CustomerDesignation: &res.CustomerDesignation,
		Address:             *res.Address,
		Flat:                *res.Flat,
		Street:              *res.Street,
		City:                res.City,
		State:               res.State,
		Pincode:             *res.Pincode,
		PaymentMode:         res.PaymentMode,
	}, nil
}

// UpdateCustomer is the resolver for the updateCustomer field.
func (r *mutationResolver) UpdateCustomer(ctx context.Context, input model.UpdateCustomerInput) (*model.Customer, error) {
	res, err := r.Resolver.Services.Customer.Update(ctx, customer.UpdateCustomerInput{
		ID:                  input.ID.String(),
		CustomerCompanyName: &input.CustomerCompanyName,
		ContactPerson:       &input.ContactPerson,
		Mobile:              &input.Mobile,
		Type:                &input.Type,
		CustomerDesignation: &input.CustomerDesignation,
		Address:             &input.Address,
		Flat:                &input.Flat,
		Street:              &input.Street,
		City:                &input.City,
		State:               &input.State,
		Pincode:             &input.Pincode,
		PaymentMode:         &input.PaymentMode,
	})
	if err != nil {
		oplog.Error(ctx,
			"UpdateCustomer failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"UpdateCustomer: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Customer updated",
		"customer_id=", res.ID,
		"name=", res.CustomerCompanyName,
	)

	return &model.Customer{
		ID:                  u,
		CustomerCompanyName: res.CustomerCompanyName,
		ContactPerson:       res.ContactPerson,
		Mobile:              res.Mobile,
		Type:                res.Type,
		CustomerDesignation: &res.CustomerDesignation,
		Address:             *res.Address,
		Flat:                *res.Flat,
		Street:              *res.Street,
		City:                res.City,
		State:               res.State,
		Pincode:             *res.Pincode,
		PaymentMode:         res.PaymentMode,
	}, nil
}

// CreateVendor is the resolver for the createVendor field.
func (r *mutationResolver) CreateVendor(ctx context.Context, input model.CreateVendorInput) (*model.Vendor, error) {
	contacts := make([]vendor.VendorContactInput, 0, len(input.VendorContacts))

	for _, c := range input.VendorContacts {
		contacts = append(contacts, vendor.VendorContactInput{
			VendorContactPerson: c.VendorContactPerson,
			MobileNumber:        c.MobileNumber,
			EmailID:             c.EmailID,
		})
	}

	res, err := r.Resolver.Services.Vendor.Create(ctx, vendor.CreateVendorInput{
		CompanyName:    input.CompanyName,
		VendorContacts: contacts,
	})
	if err != nil {
		oplog.Error(ctx,
			"CreateVendor failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"CreateVendor: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Vendor created",
		"vendor_id=", res.ID,
		"name=", res.CompanyName,
	)

	_contacts := make([]*model.VendorContact, 0, len(res.VendorContacts))

	for _, c := range res.VendorContacts {
		_contacts = append(_contacts, &model.VendorContact{
			ContactPerson: c.ContactPerson,
			MobileNumber:  c.MobileNumber,
			EmailID:       c.EmailID,
		})
	}

	return &model.Vendor{
		ID:             u,
		CompanyName:    res.CompanyName,
		VendorContacts: _contacts,
	}, nil
}

// UpdateVendor is the resolver for the updateVendor field.
func (r *mutationResolver) UpdateVendor(ctx context.Context, input model.UpdateVendorInput) (*model.Vendor, error) {
	contacts := make([]vendor.VendorContactInput, len(input.VendorContacts))

	for i, c := range input.VendorContacts {
		contacts[i] = vendor.VendorContactInput{
			VendorContactPerson: c.VendorContactPerson,
			MobileNumber:        c.MobileNumber,
			EmailID:             c.EmailID,
		}
	}

	res, err := r.Resolver.Services.Vendor.Update(ctx, vendor.UpdateVendorInput{
		CompanyName:    input.CompanyName,
		VendorContacts: contacts,
	})
	if err != nil {
		oplog.Error(ctx,
			"UpdateVendor failed",
			"err=", err,
		)
		return nil, mapCompanyError(err)
	}

	u, err := uuid.Parse(res.ID)
	if err != nil {
		oplog.Error(ctx,
			"UpdateVendor: invalid UUID returned from domain",
			"id=", res.ID,
			"err=", err,
		)
		return nil, gqlerror.Errorf("internal error")
	}

	oplog.Info(ctx,
		"Vendor created",
		"vendor_id=", res.ID,
		"name=", res.CompanyName,
	)

	_contacts := make([]*model.VendorContact, len(res.VendorContacts))

	for _, c := range res.VendorContacts {
		_contacts = append(_contacts, &model.VendorContact{
			ContactPerson: c.ContactPerson,
			MobileNumber:  c.MobileNumber,
			EmailID:       c.EmailID,
		})
	}

	return &model.Vendor{
		ID:             u,
		CompanyName:    res.CompanyName,
		VendorContacts: _contacts,
	}, nil
}

// CreateTicket is the resolver for the createTicket field.
func (r *mutationResolver) CreateTicket(ctx context.Context, input model.CreateOrderTicketInput) (*model.OrderTicket, error) {
	panic(fmt.Errorf("not implemented: CreateTicket - createTicket"))
}

// UpdateTicket is the resolver for the updateTicket field.
func (r *mutationResolver) UpdateTicket(ctx context.Context, input model.UpdateOrderTicketInput) (*model.OrderTicket, error) {
	panic(fmt.Errorf("not implemented: UpdateTicket - updateTicket"))
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input *model.CreateProductInput) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: CreateProduct - createProduct"))
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input *model.UpdateProductInput) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: UpdateProduct - updateProduct"))
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, input *model.DeleteProductInput) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: DeleteProduct - deleteProduct"))
}

// CreateOutOfStockOrder is the resolver for the createOutOfStockOrder field.
func (r *mutationResolver) CreateOutOfStockOrder(ctx context.Context, input model.CreateInventoryOrderInput) (*model.InventoryOrder, error) {
	panic(fmt.Errorf("not implemented: CreateOutOfStockOrder - createOutOfStockOrder"))
}

// UpdateOutOfStockOrder is the resolver for the updateOutOfStockOrder field.
func (r *mutationResolver) UpdateOutOfStockOrder(ctx context.Context, input model.UpdateInventoryOrderInput) (*model.InventoryOrder, error) {
	panic(fmt.Errorf("not implemented: UpdateOutOfStockOrder - updateOutOfStockOrder"))
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
